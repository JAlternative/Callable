<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2" properties="5.0" jmeter="5.5">
  <hashTree>
    <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="Чистит ростеры и создаёт свободные смены в подразделениях" enabled="true">
      <stringProp name="TestPlan.comments"></stringProp>
      <boolProp name="TestPlan.functional_mode">false</boolProp>
      <boolProp name="TestPlan.tearDown_on_shutdown">true</boolProp>
      <boolProp name="TestPlan.serialize_threadgroups">false</boolProp>
      <elementProp name="TestPlan.user_defined_variables" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
        <collectionProp name="Arguments.arguments"/>
      </elementProp>
      <stringProp name="TestPlan.user_define_classpath"></stringProp>
    </TestPlan>
    <hashTree>
      <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
        <collectionProp name="Arguments.arguments">
          <elementProp name="BASE_URL" elementType="Argument">
            <stringProp name="Argument.name">BASE_URL</stringProp>
            <stringProp name="Argument.value">goodt-pochta-loadqa.goodt.me</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">Ссылка для перехода в приложение</stringProp>
          </elementProp>
          <elementProp name="PROTOCOL" elementType="Argument">
            <stringProp name="Argument.name">PROTOCOL</stringProp>
            <stringProp name="Argument.value">https</stringProp>
            <stringProp name="Argument.desc">протокол https/http</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="influx_db" elementType="Argument">
            <stringProp name="Argument.name">influx_db</stringProp>
            <stringProp name="Argument.value">lkkbd</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="influx_url" elementType="Argument">
            <stringProp name="Argument.name">influx_url</stringProp>
            <stringProp name="Argument.value">${__P(influx_db_url,http://localhost:8086/write?db=lkkbd)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="influx_application" elementType="Argument">
            <stringProp name="Argument.name">influx_application</stringProp>
            <stringProp name="Argument.value">${__P(influx_db_application,apple)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="influx_measurement" elementType="Argument">
            <stringProp name="Argument.name">influx_measurement</stringProp>
            <stringProp name="Argument.value">${__P(influx_db_measurement,belialfff)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="count_free_shifts" elementType="Argument">
            <stringProp name="Argument.name">count_free_shifts</stringProp>
            <stringProp name="Argument.value">1200000</stringProp>
            <stringProp name="Argument.desc">Сколько нужно создать свободных смен</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="countToken" elementType="Argument">
            <stringProp name="Argument.name">countToken</stringProp>
            <stringProp name="Argument.value">0</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="countUsers" elementType="Argument">
            <stringProp name="Argument.name">countUsers</stringProp>
            <stringProp name="Argument.value">0</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="countsUsersOnOM" elementType="Argument">
            <stringProp name="Argument.name">countsUsersOnOM</stringProp>
            <stringProp name="Argument.value">2</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="OUTSTAFF_URL" elementType="Argument">
            <stringProp name="Argument.name">OUTSTAFF_URL</stringProp>
            <stringProp name="Argument.value">lkk-load-qa.goodt.tech</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
        </collectionProp>
      </Arguments>
      <hashTree/>
      <ConfigTestElement guiclass="HttpDefaultsGui" testclass="ConfigTestElement" testname="HTTP Request Defaults" enabled="true">
        <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
          <collectionProp name="Arguments.arguments"/>
        </elementProp>
        <stringProp name="HTTPSampler.domain">${BASE_URL}</stringProp>
        <stringProp name="HTTPSampler.port"></stringProp>
        <stringProp name="HTTPSampler.protocol">${PROTOCOL}</stringProp>
        <stringProp name="HTTPSampler.contentEncoding"></stringProp>
        <stringProp name="HTTPSampler.path"></stringProp>
        <stringProp name="HTTPSampler.concurrentPool">6</stringProp>
        <stringProp name="HTTPSampler.connect_timeout"></stringProp>
        <stringProp name="HTTPSampler.response_timeout"></stringProp>
      </ConfigTestElement>
      <hashTree/>
      <CookieManager guiclass="CookiePanel" testclass="CookieManager" testname="HTTP Cookie Manager" enabled="true">
        <collectionProp name="CookieManager.cookies"/>
        <boolProp name="CookieManager.clearEachIteration">true</boolProp>
        <boolProp name="CookieManager.controlledByThreadGroup">false</boolProp>
      </CookieManager>
      <hashTree/>
      <AuthManager guiclass="AuthPanel" testclass="AuthManager" testname="HTTP Authorization Manager" enabled="true">
        <collectionProp name="AuthManager.auth_list">
          <elementProp name="" elementType="Authorization">
            <stringProp name="Authorization.url"></stringProp>
            <stringProp name="Authorization.username">superuser</stringProp>
            <stringProp name="Authorization.password">Wsxzaq1!</stringProp>
            <stringProp name="Authorization.domain"></stringProp>
            <stringProp name="Authorization.realm"></stringProp>
          </elementProp>
        </collectionProp>
        <boolProp name="AuthManager.controlledByThreadGroup">false</boolProp>
      </AuthManager>
      <hashTree/>
      <JDBCDataSource guiclass="TestBeanGUI" testclass="JDBCDataSource" testname="JDBC outstaff-lk-stage.goodt.me" enabled="true">
        <boolProp name="autocommit">true</boolProp>
        <stringProp name="checkQuery"></stringProp>
        <stringProp name="connectionAge">5000</stringProp>
        <stringProp name="connectionProperties"></stringProp>
        <stringProp name="dataSource">db_outstaff</stringProp>
        <stringProp name="dbUrl">jdbc:postgresql://185.241.193.30/wfm_cpa</stringProp>
        <stringProp name="driver">org.postgresql.Driver</stringProp>
        <stringProp name="initQuery"></stringProp>
        <boolProp name="keepAlive">true</boolProp>
        <stringProp name="password">mQimWaXBcDdTb</stringProp>
        <stringProp name="poolMax">0</stringProp>
        <boolProp name="preinit">false</boolProp>
        <stringProp name="timeout">10000</stringProp>
        <stringProp name="transactionIsolation">DEFAULT</stringProp>
        <stringProp name="trimInterval">60000</stringProp>
        <stringProp name="username">s_khoroshkov</stringProp>
      </JDBCDataSource>
      <hashTree/>
      <JDBCDataSource guiclass="TestBeanGUI" testclass="JDBCDataSource" testname="JDBC magnit" enabled="true">
        <boolProp name="autocommit">true</boolProp>
        <stringProp name="checkQuery"></stringProp>
        <stringProp name="connectionAge">5000</stringProp>
        <stringProp name="connectionProperties"></stringProp>
        <stringProp name="dataSource">db_magnit</stringProp>
        <stringProp name="dbUrl">jdbc:postgresql://185.86.147.35/hrportal_magnit</stringProp>
        <stringProp name="driver">org.postgresql.Driver</stringProp>
        <stringProp name="initQuery"></stringProp>
        <boolProp name="keepAlive">true</boolProp>
        <stringProp name="password">FWFM77W1tRlAN</stringProp>
        <stringProp name="poolMax">0</stringProp>
        <boolProp name="preinit">false</boolProp>
        <stringProp name="timeout">10000</stringProp>
        <stringProp name="transactionIsolation">DEFAULT</stringProp>
        <stringProp name="trimInterval">60000</stringProp>
        <stringProp name="username">s_khoroshkov</stringProp>
      </JDBCDataSource>
      <hashTree/>
      <BackendListener guiclass="BackendListenerGui" testclass="BackendListener" testname="Backend Listener" enabled="false">
        <elementProp name="arguments" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" enabled="true">
          <collectionProp name="Arguments.arguments">
            <elementProp name="influxdbMetricsSender" elementType="Argument">
              <stringProp name="Argument.name">influxdbMetricsSender</stringProp>
              <stringProp name="Argument.value">org.apache.jmeter.visualizers.backend.influxdb.HttpMetricsSender</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="influxdbUrl" elementType="Argument">
              <stringProp name="Argument.name">influxdbUrl</stringProp>
              <stringProp name="Argument.value">${influx_url}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="application" elementType="Argument">
              <stringProp name="Argument.name">application</stringProp>
              <stringProp name="Argument.value">${influx_application}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="measurement" elementType="Argument">
              <stringProp name="Argument.name">measurement</stringProp>
              <stringProp name="Argument.value">${influx_measurement}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="summaryOnly" elementType="Argument">
              <stringProp name="Argument.name">summaryOnly</stringProp>
              <stringProp name="Argument.value">false</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="samplersRegex" elementType="Argument">
              <stringProp name="Argument.name">samplersRegex</stringProp>
              <stringProp name="Argument.value">[US|TC|&lt;|&gt;].*</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="percentiles" elementType="Argument">
              <stringProp name="Argument.name">percentiles</stringProp>
              <stringProp name="Argument.value">99;95;90</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="testTitle" elementType="Argument">
              <stringProp name="Argument.name">testTitle</stringProp>
              <stringProp name="Argument.value">Test name</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="eventTags" elementType="Argument">
              <stringProp name="Argument.name">eventTags</stringProp>
              <stringProp name="Argument.value"></stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="samplersRegex2" elementType="Argument">
              <stringProp name="Argument.name">samplersRegex2</stringProp>
              <stringProp name="Argument.value">[TC|&lt;|&gt;].*</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
          </collectionProp>
        </elementProp>
        <stringProp name="classname">org.apache.jmeter.visualizers.backend.influxdb.InfluxdbBackendListenerClient</stringProp>
      </BackendListener>
      <hashTree/>
      <TestFragmentController guiclass="TestFragmentControllerGui" testclass="TestFragmentController" testname="________________________________________________________________________________________" enabled="false"/>
      <hashTree/>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="1. Записать подразделения в файл для очистки ростеров" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Очистить csv файл" enabled="true">
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="script">import org.apache.commons.lang3.RandomStringUtils;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

String filePath = &quot;orgUnits.csv&quot;;

    try {
	
	FileWriter fw = new FileWriter(filePath, false); 
	fw.close();
    } 
    catch (IOException e) {
        e.printStackTrace().toString();
    }
</stringProp>
          <stringProp name="scriptLanguage">java</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Расчитать, сколько потребуется подразделений и свободных смен в них" enabled="false">
          <stringProp name="scriptLanguage">java</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">	   import java.time.LocalDate;
	   import java.time.temporal.TemporalAdjusters;
	   
	   int totalShiftsNeeded = Integer.valueOf(vars.get(&quot;count_free_shifts&quot;));
        int shiftsPerDay = 720; // 1440 минут в сутках / 2 минуты на смену
        vars.put(&quot;shiftsPerDay&quot;, String.valueOf(shiftsPerDay));

        LocalDate today = LocalDate.now();
        LocalDate endOfMonth = today.with(TemporalAdjusters.lastDayOfMonth());
        int remainingDays = endOfMonth.getDayOfMonth() - today.getDayOfMonth() + 1; //Оставшееся количество дней в этом месяце

        int shiftsThisMonthPerDivision = shiftsPerDay * remainingDays; //Смены, которые можно создать в одном подразделении
        int requiredDivisions = (int) Math.ceil((double) totalShiftsNeeded / shiftsThisMonthPerDivision); //Необходимое количество подразделений

        if (shiftsThisMonthPerDivision &gt; totalShiftsNeeded){
            shiftsThisMonthPerDivision = totalShiftsNeeded;
        }
        vars.put(&quot;shiftsThisMonthPerDivision&quot;, String.valueOf(shiftsThisMonthPerDivision));
        vars.put(&quot;requiredDivisions&quot;, String.valueOf(requiredDivisions));</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Расчитать, сколько потребуется подразделений и свободных смен в них 3 минуты" enabled="true">
          <stringProp name="scriptLanguage">java</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">	   import java.time.LocalDate;
	   import java.time.temporal.TemporalAdjusters;
	   
	   int totalShiftsNeeded = Integer.valueOf(vars.get(&quot;count_free_shifts&quot;));
        int shiftsPerDay = 1440 / 6; // 1440 минут в сутках / 6 минут на смену (4 минуты работы + 2 минуты перерыва)
        vars.put(&quot;shiftsPerDay&quot;, String.valueOf(shiftsPerDay));

        LocalDate today = LocalDate.now();
        LocalDate endOfMonth = today.with(TemporalAdjusters.lastDayOfMonth());
        int remainingDays = endOfMonth.getDayOfMonth() - today.getDayOfMonth() + 1; //Оставшееся количество дней в этом месяце

        int shiftsThisMonthPerDivision = shiftsPerDay * remainingDays; //Смены, которые можно создать в одном подразделении
        int requiredDivisions = (int) Math.ceil((double) totalShiftsNeeded / shiftsThisMonthPerDivision); //Необходимое количество подразделений

        if (shiftsThisMonthPerDivision &gt; totalShiftsNeeded){
            shiftsThisMonthPerDivision = totalShiftsNeeded;
        }
        vars.put(&quot;shiftsThisMonthPerDivision&quot;, String.valueOf(shiftsThisMonthPerDivision));
        vars.put(&quot;requiredDivisions&quot;, String.valueOf(requiredDivisions));</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Получить все оргюниты с магнита" enabled="true">
          <stringProp name="dataSource">db_magnit</stringProp>
          <stringProp name="query">SELECT DISTINCT o.id
FROM organizationunit o
JOIN roster r ON o.id = r.org_unit_id
JOIN entity_property_org_unit epou ON o.id = epou.org_unit_id
JOIN entity_property_value epv ON epou.value_id = epv.id
WHERE availableforcalculation = true 
and o.id &gt; 0 and o.id != 79 and o.id != 80 and o.id != 88 and o.id != 98 and o.id != 110 and o.id != 114 and o.id != 126 and o.id != 124
LIMIT ${requiredDivisions}</stringProp>
          <stringProp name="queryArguments"></stringProp>
          <stringProp name="queryArgumentsTypes"></stringProp>
          <stringProp name="queryTimeout"></stringProp>
          <stringProp name="queryType">Select Statement</stringProp>
          <stringProp name="resultSetHandler">Store as String</stringProp>
          <stringProp name="resultSetMaxRows"></stringProp>
          <stringProp name="resultVariable"></stringProp>
          <stringProp name="variableNames">orgUnitsId</stringProp>
        </JDBCSampler>
        <hashTree/>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Записать подразделения в csv файл" enabled="true">
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="script">import org.apache.commons.lang3.RandomStringUtils;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

String filePath = &quot;orgUnits.csv&quot;;
Integer value = Integer.parseInt(vars.get(&quot;orgUnitsId_#&quot;));

FileWriter fw = null;
try {
    fw = new FileWriter(filePath, true);
    File file = new File(filePath);
    if (file.length() == 0) {
        fw.write(&quot;omId\n&quot;);
    }

    for (int a = 1; a &lt;= value; a++) {
    	   String variable = &quot;orgUnitsId_&quot; + a;
        fw.write(vars.get(variable) + &quot;\n&quot;);
    }
    fw.close();
} catch (IOException e) {
    e.printStackTrace();
}

</stringProp>
          <stringProp name="scriptLanguage">java</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <DebugSampler guiclass="TestBeanGUI" testclass="DebugSampler" testname="Debug Sampler" enabled="true">
          <boolProp name="displayJMeterProperties">false</boolProp>
          <boolProp name="displayJMeterVariables">true</boolProp>
          <boolProp name="displaySystemProperties">false</boolProp>
        </DebugSampler>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="2. Удалить ростеры у подразделений (очистить все смены у сотрудников)" enabled="false">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">3</stringProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
      </ThreadGroup>
      <hashTree>
        <BeanShellSampler guiclass="BeanShellSamplerGui" testclass="BeanShellSampler" testname="Dates" enabled="true">
          <stringProp name="BeanShellSampler.query">import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;
import java.time.temporal.TemporalAdjusters;


    LocalDate date = LocalDate.now();
    vars.put(&quot;numberCurrentMonth&quot;, String.valueOf(date.getMonthValue()));
    vars.put(&quot;dateOnShift&quot;,date.toString());
    vars.put(&quot;startTime&quot;,&quot;00:00:00.000000&quot;);
    vars.put(&quot;endTime&quot;,&quot;00:03:00.000000&quot;); // Начнем с интервала 1 минута
    String dateToday = String.valueOf(date);
    String dateStart = String.valueOf(date.withDayOfMonth(1));
    String dateEnd = String.valueOf(date.withDayOfMonth(date.lengthOfMonth()));
    String dateMonthAgo = String.valueOf(date.minusMonths(1));
    String dateNextYear = String.valueOf(date.plusYears(1));
    String dateStartYear = String.valueOf(date.withDayOfYear(1));
    String dateYesterday = &quot;&quot;;

    String dateNow = String.valueOf(LocalDate.now());
    String end = dateNow + &quot; 18:05:00.000000&quot;;
    String start = dateNow + &quot; 09:05:00.000000&quot;;
    String createStart = dateNow + &quot; 03:33:00.000000&quot;;
    String createUpdate = dateNow + &quot; 03:34:00.000000&quot;;
    String tStart = dateNow + &quot;T09:05:00&quot;;
    String tEnd = dateNow + &quot;T18:05:00&quot;;
    
    vars.put(&quot;dend&quot;,end);
    vars.put(&quot;dstart&quot;,start);
    vars.put(&quot;createStart&quot;,createStart);
    vars.put(&quot;createUpdate&quot;,createUpdate);
    vars.put(&quot;tStart&quot;,tStart);
    vars.put(&quot;tEnd&quot;,tEnd);

    if(date.equals(date.withDayOfMonth(1)))
    {
        dateYesterday = dateToday;
    } else {
        dateYesterday = String.valueOf(date.minusDays(1));
    } 
    
    vars.put(&quot;DATE_NOW&quot;,dateToday);
    vars.put(&quot;DATE_START_MONTH&quot;,dateStart);
    vars.put(&quot;DATE_END_MONTH&quot;,dateEnd);
    vars.put(&quot;DATE_MONTH_AGO&quot;,dateMonthAgo);
    vars.put(&quot;DATE_YESTERDAY&quot;,dateYesterday);
    vars.put(&quot;DATE_NEXT_YEAR&quot;,dateNextYear);
    vars.put(&quot;DATE_START_YEAR&quot;,dateStartYear);

    int countShifts = Integer.valueOf(vars.get(&quot;count_free_shifts&quot;));
    LocalDate localDate = LocalDate.now();
    LocalDate endOfMonths = localDate.with(TemporalAdjusters.lastDayOfMonth());
    int remainingDays = endOfMonths.getDayOfMonth() - localDate.getDayOfMonth() + 1; //Оставшееся количество дней в этом месяце
    int countShiftsInDay = countShifts / remainingDays;

    vars.put(&quot;remainingDays&quot;,String.valueOf(remainingDays));
    vars.put(&quot;countShiftsInDay&quot;,String.valueOf(countShiftsInDay));

    List datesToMonthEnd = new ArrayList();
    LocalDate endOfMonth = date.withDayOfMonth(date.lengthOfMonth());
    datesToMonthEnd.add(date.toString());
    while(!endOfMonth.equals(date))
    {
        datesToMonthEnd.add(endOfMonth.toString());
        endOfMonth = endOfMonth.minusDays(1);
    }

    int counter = 1;
    for(
    int i = 0; i&lt;datesToMonthEnd.size();i++)
    {
        String varName = &quot;varDates_&quot; + String.valueOf(counter);
        counter += 1;
        vars.put(varName, datesToMonthEnd.get(i));
    }
    vars.put(&quot;varCounter&quot;,String.valueOf(datesToMonthEnd.size()));
        </stringProp>
          <stringProp name="BeanShellSampler.filename"></stringProp>
          <stringProp name="BeanShellSampler.parameters"></stringProp>
          <boolProp name="BeanShellSampler.resetInterpreter">false</boolProp>
        </BeanShellSampler>
        <hashTree/>
        <DebugSampler guiclass="TestBeanGUI" testclass="DebugSampler" testname="Debug Sampler" enabled="true">
          <boolProp name="displayJMeterProperties">false</boolProp>
          <boolProp name="displayJMeterVariables">true</boolProp>
          <boolProp name="displaySystemProperties">false</boolProp>
        </DebugSampler>
        <hashTree/>
        <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="CSV Data Set Config" enabled="true">
          <stringProp name="delimiter">,</stringProp>
          <stringProp name="fileEncoding"></stringProp>
          <stringProp name="filename">orgUnits.csv</stringProp>
          <boolProp name="ignoreFirstLine">true</boolProp>
          <boolProp name="quotedData">false</boolProp>
          <boolProp name="recycle">false</boolProp>
          <stringProp name="shareMode">shareMode.all</stringProp>
          <boolProp name="stopThread">false</boolProp>
          <stringProp name="variableNames">orgUnitId</stringProp>
        </CSVDataSet>
        <hashTree/>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">vars.put(&quot;count&quot;,&quot;0&quot;);</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Удалить все смены за текущий месяц у оргюнита" enabled="true">
          <stringProp name="dataSource">db_magnit</stringProp>
          <stringProp name="query">DELETE FROM shift s
WHERE org_unit_id = ${orgUnitId}
AND EXTRACT(MONTH FROM s.startDateTime) = EXTRACT(MONTH FROM CURRENT_DATE)
AND EXTRACT(YEAR FROM s.startDateTime) = EXTRACT(YEAR FROM CURRENT_DATE)</stringProp>
          <stringProp name="queryArguments"></stringProp>
          <stringProp name="queryArgumentsTypes"></stringProp>
          <stringProp name="queryTimeout"></stringProp>
          <stringProp name="queryType">Update Statement</stringProp>
          <stringProp name="resultSetHandler">Store as String</stringProp>
          <stringProp name="resultSetMaxRows"></stringProp>
          <stringProp name="resultVariable"></stringProp>
          <stringProp name="variableNames">rosterId</stringProp>
        </JDBCSampler>
        <hashTree/>
        <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Ростеры у подразделения" enabled="true">
          <stringProp name="dataSource">db_magnit</stringProp>
          <stringProp name="query">SELECT *
FROM roster r
WHERE org_unit_id = ${orgUnitId}
  AND &quot;month&quot; = ${numberCurrentMonth}
  AND EXTRACT(YEAR FROM creationtime) IN (EXTRACT(YEAR FROM CURRENT_DATE), EXTRACT(YEAR FROM CURRENT_DATE) - 1);
</stringProp>
          <stringProp name="queryArguments"></stringProp>
          <stringProp name="queryArgumentsTypes"></stringProp>
          <stringProp name="queryTimeout"></stringProp>
          <stringProp name="queryType">Select Statement</stringProp>
          <stringProp name="resultSetHandler">Store as String</stringProp>
          <stringProp name="resultSetMaxRows"></stringProp>
          <stringProp name="resultVariable"></stringProp>
          <stringProp name="variableNames">rosterId</stringProp>
        </JDBCSampler>
        <hashTree/>
        <LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">true</boolProp>
          <stringProp name="LoopController.loops">${rosterId_#}</stringProp>
        </LoopController>
        <hashTree>
          <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler" enabled="true">
            <stringProp name="scriptLanguage">java</stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="cacheKey">true</stringProp>
            <stringProp name="script">String counts = vars.get(&quot;count&quot;);
Integer numb = Integer.valueOf(counts) + 1;
String variable = &quot;rosterId_&quot; + numb;
vars.put(&quot;count&quot;, String.valueOf(numb));
vars.put(&quot;rostersId&quot;, vars.get(variable));</stringProp>
          </JSR223Sampler>
          <hashTree/>
          <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Удалить positionCategoryRoster" enabled="true">
            <stringProp name="dataSource">db_magnit</stringProp>
            <stringProp name="query">DELETE FROM positioncategoryroster WHERE roster_id = ${rostersId};</stringProp>
            <stringProp name="queryArguments"></stringProp>
            <stringProp name="queryArgumentsTypes"></stringProp>
            <stringProp name="queryTimeout"></stringProp>
            <stringProp name="queryType">Update Statement</stringProp>
            <stringProp name="resultSetHandler">Store as String</stringProp>
            <stringProp name="resultSetMaxRows"></stringProp>
            <stringProp name="resultVariable"></stringProp>
            <stringProp name="variableNames"></stringProp>
          </JDBCSampler>
          <hashTree/>
          <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Удалить ростеры у подразделения" enabled="true">
            <stringProp name="dataSource">db_magnit</stringProp>
            <stringProp name="query">DELETE FROM roster WHERE id = ${rostersId};</stringProp>
            <stringProp name="queryArguments"></stringProp>
            <stringProp name="queryArgumentsTypes"></stringProp>
            <stringProp name="queryTimeout"></stringProp>
            <stringProp name="queryType">Update Statement</stringProp>
            <stringProp name="resultSetHandler">Store as String</stringProp>
            <stringProp name="resultSetMaxRows"></stringProp>
            <stringProp name="resultVariable"></stringProp>
            <stringProp name="variableNames"></stringProp>
          </JDBCSampler>
          <hashTree/>
          <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Удалить ростер_архив у подразделения" enabled="true">
            <stringProp name="dataSource">db_magnit</stringProp>
            <stringProp name="query">DELETE FROM roster_archive r WHERE originalroster_id = ${rostersId};</stringProp>
            <stringProp name="queryArguments"></stringProp>
            <stringProp name="queryArgumentsTypes"></stringProp>
            <stringProp name="queryTimeout"></stringProp>
            <stringProp name="queryType">Update Statement</stringProp>
            <stringProp name="resultSetHandler">Store as String</stringProp>
            <stringProp name="resultSetMaxRows"></stringProp>
            <stringProp name="resultVariable"></stringProp>
            <stringProp name="variableNames"></stringProp>
          </JDBCSampler>
          <hashTree/>
          <DebugSampler guiclass="TestBeanGUI" testclass="DebugSampler" testname="Debug Sampler" enabled="true">
            <boolProp name="displayJMeterProperties">false</boolProp>
            <boolProp name="displayJMeterVariables">true</boolProp>
            <boolProp name="displaySystemProperties">false</boolProp>
          </DebugSampler>
          <hashTree/>
        </hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">vars.put(&quot;count&quot;,&quot;0&quot;);</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <TransactionController guiclass="TransactionControllerGui" testclass="TransactionController" testname="Создать пустой ростер" enabled="true">
          <boolProp name="TransactionController.includeTimers">false</boolProp>
          <boolProp name="TransactionController.parent">false</boolProp>
        </TransactionController>
        <hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="&gt;_jobapp/cron-jobs/sys/create-empty-planned-roster" enabled="true">
            <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
              <collectionProp name="Arguments.arguments">
                <elementProp name="" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value"> {&quot;date&quot;:&quot;${DATE_NOW}&quot;,&quot;orgUnitSelf&quot;:[${orgUnitId}]}</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
            <stringProp name="HTTPSampler.domain">${BASE_URL}</stringProp>
            <stringProp name="HTTPSampler.port"></stringProp>
            <stringProp name="HTTPSampler.protocol">${PROTOCOL}</stringProp>
            <stringProp name="HTTPSampler.contentEncoding"></stringProp>
            <stringProp name="HTTPSampler.path">/jobapp/cron-jobs/sys/create-empty-planned-roster</stringProp>
            <stringProp name="HTTPSampler.method">POST</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
            <stringProp name="HTTPSampler.response_timeout"></stringProp>
          </HTTPSamplerProxy>
          <hashTree>
            <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
              <collectionProp name="HeaderManager.headers">
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Content-Type</stringProp>
                  <stringProp name="Header.value">application/hal+json</stringProp>
                </elementProp>
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Accept-Encoding</stringProp>
                  <stringProp name="Header.value">gzip, deflate, br</stringProp>
                </elementProp>
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Connection</stringProp>
                  <stringProp name="Header.value">keep-alive</stringProp>
                </elementProp>
                <elementProp name="Accept" elementType="Header">
                  <stringProp name="Header.name">Accept</stringProp>
                  <stringProp name="Header.value">*/*</stringProp>
                </elementProp>
              </collectionProp>
            </HeaderManager>
            <hashTree/>
          </hashTree>
        </hashTree>
        <TransactionController guiclass="TransactionControllerGui" testclass="TransactionController" testname="Сделать перерасчёт смен" enabled="true">
          <boolProp name="TransactionController.includeTimers">false</boolProp>
          <boolProp name="TransactionController.parent">false</boolProp>
        </TransactionController>
        <hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="&gt;_org-units/${orgUnitId}/rostering?locale=ru&amp;from=${DATE_START_MONTH}&amp;to=${DATE_END_MONTH}&amp;rerostering=false&amp;with-min-deviation=false" enabled="true">
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
              <collectionProp name="Arguments.arguments"/>
            </elementProp>
            <stringProp name="HTTPSampler.domain">${BASE_URL}</stringProp>
            <stringProp name="HTTPSampler.port"></stringProp>
            <stringProp name="HTTPSampler.protocol">${PROTOCOL}</stringProp>
            <stringProp name="HTTPSampler.contentEncoding"></stringProp>
            <stringProp name="HTTPSampler.path">/api/v1/org-units/${orgUnitId}/rostering?locale=ru&amp;from=${DATE_START_MONTH}&amp;to=${DATE_END_MONTH}&amp;rerostering=false&amp;with-min-deviation=false</stringProp>
            <stringProp name="HTTPSampler.method">POST</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
            <stringProp name="HTTPSampler.response_timeout"></stringProp>
          </HTTPSamplerProxy>
          <hashTree>
            <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
              <collectionProp name="HeaderManager.headers">
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Content-Type</stringProp>
                  <stringProp name="Header.value">application/hal+json</stringProp>
                </elementProp>
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Accept-Encoding</stringProp>
                  <stringProp name="Header.value">gzip, deflate, br</stringProp>
                </elementProp>
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Connection</stringProp>
                  <stringProp name="Header.value">keep-alive</stringProp>
                </elementProp>
                <elementProp name="Accept" elementType="Header">
                  <stringProp name="Header.name">Accept</stringProp>
                  <stringProp name="Header.value">*/*</stringProp>
                </elementProp>
              </collectionProp>
            </HeaderManager>
            <hashTree/>
          </hashTree>
        </hashTree>
        <DebugSampler guiclass="TestBeanGUI" testclass="DebugSampler" testname="Debug Sampler" enabled="true">
          <boolProp name="displayJMeterProperties">false</boolProp>
          <boolProp name="displayJMeterVariables">true</boolProp>
          <boolProp name="displaySystemProperties">false</boolProp>
        </DebugSampler>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="3. Создать свободные смены у подразделения и собрать CSV файл с данными смены (3 минуты интервал одной свободной смены)" enabled="false">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="TestPlan.comments">в подразделении 12:00-12:03 - будет создана свободная смена и так далее, следубщая 12:04-12:07</stringProp>
      </ThreadGroup>
      <hashTree>
        <TransactionController guiclass="TransactionControllerGui" testclass="TransactionController" testname="Авторизация SVP" enabled="true">
          <boolProp name="TransactionController.includeTimers">false</boolProp>
          <boolProp name="TransactionController.parent">false</boolProp>
        </TransactionController>
        <hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="&gt;_/wfm-cpa/login" enabled="true">
            <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
              <collectionProp name="Arguments.arguments">
                <elementProp name="" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value">{&#xd;
  &quot;username&quot;: &quot;svp&quot;,&#xd;
  &quot;password&quot;: &quot;svp&quot;&#xd;
}</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
            <stringProp name="HTTPSampler.domain">${OUTSTAFF_URL}</stringProp>
            <stringProp name="HTTPSampler.port"></stringProp>
            <stringProp name="HTTPSampler.protocol">${PROTOCOL}</stringProp>
            <stringProp name="HTTPSampler.contentEncoding">UTF-16</stringProp>
            <stringProp name="HTTPSampler.path">/wfm-cpa/login</stringProp>
            <stringProp name="HTTPSampler.method">POST</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
            <stringProp name="HTTPSampler.response_timeout"></stringProp>
          </HTTPSamplerProxy>
          <hashTree>
            <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
              <collectionProp name="HeaderManager.headers">
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Content-Type</stringProp>
                  <stringProp name="Header.value">application/json</stringProp>
                </elementProp>
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Accept-Encoding</stringProp>
                  <stringProp name="Header.value">gzip, deflate, br</stringProp>
                </elementProp>
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Connection</stringProp>
                  <stringProp name="Header.value">keep-alive</stringProp>
                </elementProp>
                <elementProp name="Accept" elementType="Header">
                  <stringProp name="Header.name">Accept</stringProp>
                  <stringProp name="Header.value">*/*</stringProp>
                </elementProp>
              </collectionProp>
            </HeaderManager>
            <hashTree/>
            <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="Regular Expression Extractor" enabled="true">
              <stringProp name="RegexExtractor.useHeaders">true</stringProp>
              <stringProp name="RegexExtractor.refname">TOKEN</stringProp>
              <stringProp name="RegexExtractor.regex">Authorization: (.+).</stringProp>
              <stringProp name="RegexExtractor.template">$1$</stringProp>
              <stringProp name="RegexExtractor.default"></stringProp>
              <stringProp name="RegexExtractor.match_number"></stringProp>
            </RegexExtractor>
            <hashTree/>
          </hashTree>
          <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Преобразовать строку в TOKEN" enabled="true">
            <stringProp name="scriptLanguage">java</stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="cacheKey">true</stringProp>
            <stringProp name="script">String token = vars.get(&quot;TOKEN_g0&quot;); // Почему то TOKEN он не весь достаётся, приходится вытаскивать из TOKEN_g0
int startIndex = token.indexOf(&quot;Authorization: &quot;) + &quot;Authorization: &quot;.length();
String extractedToken = token.substring(startIndex);
vars.put(&quot;TOKEN&quot;, extractedToken);</stringProp>
          </JSR223Sampler>
          <hashTree/>
        </hashTree>
        <BeanShellSampler guiclass="BeanShellSamplerGui" testclass="BeanShellSampler" testname="Dates" enabled="true">
          <stringProp name="BeanShellSampler.query">import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;


LocalDate date = LocalDate.now();
String dateToday = String.valueOf(date);
String dateStart = String.valueOf(date.withDayOfMonth(1));
String dateEnd = String.valueOf(date.withDayOfMonth(date.lengthOfMonth()));
String dateMonthAgo = String.valueOf(date.minusMonths(1));
String dateNextYear = String.valueOf(date.plusYears(1));
String dateStartYear = String.valueOf(date.withDayOfYear(1));
String dateYesterday = &quot;&quot;;

String dateNow = String.valueOf(LocalDate.now());
String end = dateNow +&quot; 18:05:00.000000&quot;;
String start = dateNow +&quot; 09:05:00.000000&quot;;
String createStart = dateNow +&quot; 03:33:00.000000&quot;;
String createUpdate = dateNow + &quot; 03:34:00.000000&quot;;
String tStart = dateNow + &quot;T09:05:00&quot;;
String tEnd = dateNow + &quot;T18:05:00&quot;;
vars.put(&quot;dend&quot;, end);
vars.put(&quot;dstart&quot;, start);
vars.put(&quot;createStart&quot;, createStart);
vars.put(&quot;createUpdate&quot;, createUpdate);
vars.put(&quot;tStart&quot;, tStart);
vars.put(&quot;tEnd&quot;, tEnd);

if (date.equals(date.withDayOfMonth(1))) {
	dateYesterday = dateToday;
} else {
	dateYesterday = String.valueOf(date.minusDays(1));
}
vars.put(&quot;DATE_NOW&quot;, dateToday);
vars.put(&quot;DATE_START_MONTH&quot;, dateStart);
vars.put(&quot;DATE_END_MONTH&quot;, dateEnd);
vars.put(&quot;DATE_MONTH_AGO&quot;, dateMonthAgo);
vars.put(&quot;DATE_YESTERDAY&quot;, dateYesterday);
vars.put(&quot;DATE_NEXT_YEAR&quot;, dateNextYear);
vars.put(&quot;DATE_START_YEAR&quot;, dateStartYear);

List datesToMonthEnd = new ArrayList();
LocalDate endOfMonth = date.withDayOfMonth(date.lengthOfMonth());
datesToMonthEnd.add(date.toString());
while (!endOfMonth.equals(date)) {
	datesToMonthEnd.add(endOfMonth.toString());
	endOfMonth = endOfMonth.minusDays(1);
}
int counter = 1;
for (int i = 0 ; i &lt; datesToMonthEnd.size(); i++) {
	String varName = &quot;varDates_&quot;+String.valueOf(counter);
	counter+=1;
	vars.put(varName, datesToMonthEnd.get(i));	
}
vars.put(&quot;varCounter&quot;, String.valueOf(datesToMonthEnd.size()));
        </stringProp>
          <stringProp name="BeanShellSampler.filename"></stringProp>
          <stringProp name="BeanShellSampler.parameters"></stringProp>
          <boolProp name="BeanShellSampler.resetInterpreter">false</boolProp>
        </BeanShellSampler>
        <hashTree/>
        <TransactionController guiclass="TransactionControllerGui" testclass="TransactionController" testname="Авторизация CP" enabled="true">
          <boolProp name="TransactionController.includeTimers">false</boolProp>
          <boolProp name="TransactionController.parent">false</boolProp>
        </TransactionController>
        <hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="&gt;_/wfm-cpa/login" enabled="true">
            <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
              <collectionProp name="Arguments.arguments">
                <elementProp name="" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value">{&#xd;
  &quot;username&quot;: &quot;s.khoroshkov@gmail.com&quot;,&#xd;
  &quot;password&quot;: &quot;goodtme&quot;&#xd;
}</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
            <stringProp name="HTTPSampler.domain">${OUTSTAFF_URL}</stringProp>
            <stringProp name="HTTPSampler.port"></stringProp>
            <stringProp name="HTTPSampler.protocol">${PROTOCOL}</stringProp>
            <stringProp name="HTTPSampler.contentEncoding">UTF-16</stringProp>
            <stringProp name="HTTPSampler.path">/wfm-cpa/login</stringProp>
            <stringProp name="HTTPSampler.method">POST</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
            <stringProp name="HTTPSampler.response_timeout"></stringProp>
          </HTTPSamplerProxy>
          <hashTree>
            <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
              <collectionProp name="HeaderManager.headers">
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Content-Type</stringProp>
                  <stringProp name="Header.value">application/json</stringProp>
                </elementProp>
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Accept-Encoding</stringProp>
                  <stringProp name="Header.value">gzip, deflate, br</stringProp>
                </elementProp>
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Connection</stringProp>
                  <stringProp name="Header.value">keep-alive</stringProp>
                </elementProp>
                <elementProp name="Accept" elementType="Header">
                  <stringProp name="Header.name">Accept</stringProp>
                  <stringProp name="Header.value">*/*</stringProp>
                </elementProp>
              </collectionProp>
            </HeaderManager>
            <hashTree/>
            <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="Regular Expression Extractor" enabled="true">
              <stringProp name="RegexExtractor.useHeaders">true</stringProp>
              <stringProp name="RegexExtractor.refname">TOKEN_CP</stringProp>
              <stringProp name="RegexExtractor.regex">Authorization: (.+).</stringProp>
              <stringProp name="RegexExtractor.template">$1$</stringProp>
              <stringProp name="RegexExtractor.default"></stringProp>
              <stringProp name="RegexExtractor.match_number"></stringProp>
            </RegexExtractor>
            <hashTree/>
          </hashTree>
          <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Преобразовать строку в TOKEN" enabled="true">
            <stringProp name="scriptLanguage">java</stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="cacheKey">true</stringProp>
            <stringProp name="script">String token = vars.get(&quot;TOKEN_CP_g0&quot;); // Почему то TOKEN он не весь достаётся, приходится вытаскивать из TOKEN_g0
int startIndex = token.indexOf(&quot;Authorization: &quot;) + &quot;Authorization: &quot;.length();
String extractedToken = token.substring(startIndex);
vars.put(&quot;TOKEN_CP&quot;, extractedToken);</stringProp>
          </JSR223Sampler>
          <hashTree/>
        </hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Расчитать, сколько потребуется подразделений и свободных смен в них" enabled="true">
          <stringProp name="scriptLanguage">java</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">	   import java.time.LocalDate;
	   import java.time.temporal.TemporalAdjusters;
	   
	   int totalShiftsNeeded = Integer.valueOf(vars.get(&quot;count_free_shifts&quot;));
        int shiftsPerDay = 1440 / 6; // 1440 минут в сутках / 6 минут на смену (4 минуты работы + 2 минуты перерыва)
        vars.put(&quot;shiftsPerDay&quot;, String.valueOf(shiftsPerDay));

        LocalDate today = LocalDate.now();
        LocalDate endOfMonth = today.with(TemporalAdjusters.lastDayOfMonth());
        int remainingDays = endOfMonth.getDayOfMonth() - today.getDayOfMonth() + 1; //Оставшееся количество дней в этом месяце

        int shiftsThisMonthPerDivision = shiftsPerDay * remainingDays; //Смены, которые можно создать в одном подразделении
        int requiredDivisions = (int) Math.ceil((double) totalShiftsNeeded / shiftsThisMonthPerDivision); //Необходимое количество подразделений

        if (shiftsThisMonthPerDivision &gt; totalShiftsNeeded){
            shiftsThisMonthPerDivision = totalShiftsNeeded;
        }
        vars.put(&quot;shiftsThisMonthPerDivision&quot;, String.valueOf(shiftsThisMonthPerDivision));
        vars.put(&quot;requiredDivisions&quot;, String.valueOf(requiredDivisions));</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Очистить csv файл" enabled="true">
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="script">import org.apache.commons.lang3.RandomStringUtils;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

String filePath = &quot;values.csv&quot;;
String filePathTree = &quot;viewTree.csv&quot;;

    try {
	
	FileWriter fw = new FileWriter(filePath, false); 
	FileWriter fwt = new FileWriter(filePathTree, false); 
	
	fw.close();
	fwt.close();
    } 
    catch (IOException e) {
        e.printStackTrace().toString();
        vars.put(&quot;VALUIERREQEWWEQWEWDSDW&quot;, e.printStackTrace().toString());
    }
</stringProp>
          <stringProp name="scriptLanguage">java</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Получить все оргюниты с магнита" enabled="true">
          <stringProp name="dataSource">db_magnit</stringProp>
          <stringProp name="query">SELECT DISTINCT o.id
FROM organizationunit o
JOIN roster r ON o.id = r.org_unit_id
JOIN entity_property_org_unit epou ON o.id = epou.org_unit_id
JOIN entity_property_value epv ON epou.value_id = epv.id
WHERE availableforcalculation = true and o.id &gt; 0
and o.id &gt; 0 and o.id != 79 and o.id != 80 and o.id != 88 and o.id != 98 and o.id != 110 and o.id != 114 and o.id != 126 and o.id != 124
LIMIT ${requiredDivisions}</stringProp>
          <stringProp name="queryArguments"></stringProp>
          <stringProp name="queryArgumentsTypes"></stringProp>
          <stringProp name="queryTimeout"></stringProp>
          <stringProp name="queryType">Select Statement</stringProp>
          <stringProp name="resultSetHandler">Store as String</stringProp>
          <stringProp name="resultSetMaxRows"></stringProp>
          <stringProp name="resultVariable"></stringProp>
          <stringProp name="variableNames">orgUnitsId</stringProp>
        </JDBCSampler>
        <hashTree/>
        <TransactionController guiclass="TransactionControllerGui" testclass="TransactionController" testname="Выключить настройку публикации графиков с конфликтами" enabled="true">
          <boolProp name="TransactionController.includeTimers">false</boolProp>
          <boolProp name="TransactionController.parent">false</boolProp>
        </TransactionController>
        <hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="&gt;_api/v1/system-properties/124" enabled="true">
            <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
              <collectionProp name="Arguments.arguments">
                <elementProp name="" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value">{&#xd;
  &quot;enabled&quot;: true,&#xd;
  &quot;key&quot;: &quot;roster.publish.without_conflicts&quot;,&#xd;
  &quot;title&quot;: &quot;Публикация без конфликтов&quot;,&#xd;
  &quot;description&quot;: &quot;Публикация расписания только без конфликтов&quot;,&#xd;
  &quot;value&quot;: false,&#xd;
  &quot;type&quot;: &quot;BACK&quot;,&#xd;
  &quot;dataType&quot;: &quot;BOOL&quot;,&#xd;
  &quot;tags&quot;: [&#xd;
    &quot;Публикация расписания&quot;&#xd;
  ],&#xd;
  &quot;created&quot;: &quot;2021-03-17T15:39:21.3073&quot;,&#xd;
  &quot;updated&quot;: &quot;2023-11-08T08:10:29.636474&quot;,&#xd;
  &quot;_links&quot;: {&#xd;
    &quot;self&quot;: {&#xd;
      &quot;href&quot;: &quot;https://magnit-master.goodt.me/api/v1/system-properties/124&quot;&#xd;
    }&#xd;
  },&#xd;
  &quot;id&quot;: null&#xd;
}</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
            <stringProp name="HTTPSampler.domain">${BASE_URL}</stringProp>
            <stringProp name="HTTPSampler.port"></stringProp>
            <stringProp name="HTTPSampler.protocol">${PROTOCOL}</stringProp>
            <stringProp name="HTTPSampler.contentEncoding"></stringProp>
            <stringProp name="HTTPSampler.path">api/v1/system-properties/124</stringProp>
            <stringProp name="HTTPSampler.method">PUT</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
            <stringProp name="HTTPSampler.response_timeout"></stringProp>
          </HTTPSamplerProxy>
          <hashTree>
            <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
              <collectionProp name="HeaderManager.headers">
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Content-Type</stringProp>
                  <stringProp name="Header.value">application/hal+json</stringProp>
                </elementProp>
              </collectionProp>
            </HeaderManager>
            <hashTree/>
          </hashTree>
        </hashTree>
        <DebugSampler guiclass="TestBeanGUI" testclass="DebugSampler" testname="Debug Sampler" enabled="true">
          <boolProp name="displayJMeterProperties">false</boolProp>
          <boolProp name="displayJMeterVariables">true</boolProp>
          <boolProp name="displaySystemProperties">false</boolProp>
        </DebugSampler>
        <hashTree/>
        <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach Controller" enabled="true">
          <stringProp name="TestPlan.comments">Добавить в каждый оргюнит свободные смены</stringProp>
          <stringProp name="ForeachController.inputVal">orgUnitsId</stringProp>
          <stringProp name="ForeachController.returnVal">orgUnitId</stringProp>
          <boolProp name="ForeachController.useSeparator">true</boolProp>
          <stringProp name="ForeachController.startIndex">0</stringProp>
          <stringProp name="ForeachController.endIndex">${orgUnitsId_#}</stringProp>
        </ForeachController>
        <hashTree>
          <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Сохранить текущую дату" enabled="true">
            <stringProp name="scriptLanguage">java</stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="cacheKey">true</stringProp>
            <stringProp name="script">	   import java.time.LocalDate;

	   LocalDate date = LocalDate.now();
	   vars.put(&quot;dateOnShift&quot;, date.toString());
	   vars.put(&quot;startTime&quot;, &quot;00:00:00.000000&quot;);
        vars.put(&quot;endTime&quot;, &quot;00:03:00.000000&quot;); // Начнем с интервала 1 минута

  	   </stringProp>
          </JSR223Sampler>
          <hashTree/>
          <DebugSampler guiclass="TestBeanGUI" testclass="DebugSampler" testname="DEBUG после сохранения дат" enabled="true">
            <boolProp name="displayJMeterProperties">false</boolProp>
            <boolProp name="displayJMeterVariables">true</boolProp>
            <boolProp name="displaySystemProperties">false</boolProp>
          </DebugSampler>
          <hashTree/>
          <LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
            <boolProp name="LoopController.continue_forever">true</boolProp>
            <stringProp name="LoopController.loops">${countsUsersOnOM}</stringProp>
          </LoopController>
          <hashTree>
            <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Увеличить количество пользователей" enabled="true">
              <stringProp name="scriptLanguage">java</stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="cacheKey">true</stringProp>
              <stringProp name="script">int countShifts = Integer.valueOf(vars.get(&quot;shiftsThisMonthPerDivision&quot;));
int countShiftOnOm = countShifts / Integer.valueOf(vars.get(&quot;countsUsersOnOM&quot;));
vars.put(&quot;countShiftOnOm&quot;, String.valueOf(countShiftOnOm));
</stringProp>
            </JSR223Sampler>
            <hashTree/>
            <DebugSampler guiclass="TestBeanGUI" testclass="DebugSampler" testname="DEBUG после пользователей" enabled="true">
              <boolProp name="displayJMeterProperties">false</boolProp>
              <boolProp name="displayJMeterVariables">true</boolProp>
              <boolProp name="displaySystemProperties">false</boolProp>
            </DebugSampler>
            <hashTree/>
            <TransactionController guiclass="TransactionControllerGui" testclass="TransactionController" testname="Создать пустой ростер" enabled="true">
              <boolProp name="TransactionController.includeTimers">false</boolProp>
              <boolProp name="TransactionController.parent">false</boolProp>
            </TransactionController>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="&gt;_api/v1/sys/create-empty-planned-roster" enabled="true">
                <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">false</boolProp>
                      <stringProp name="Argument.value"> {&quot;date&quot;:&quot;${DATE_NOW}&quot;,&quot;orgUnitSelf&quot;:[${orgUnitId}]}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${BASE_URL}</stringProp>
                <stringProp name="HTTPSampler.port"></stringProp>
                <stringProp name="HTTPSampler.protocol">${PROTOCOL}</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/v1/sys/create-empty-planned-roster</stringProp>
                <stringProp name="HTTPSampler.method">POST</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
                  <collectionProp name="HeaderManager.headers">
                    <elementProp name="" elementType="Header">
                      <stringProp name="Header.name">Content-Type</stringProp>
                      <stringProp name="Header.value">application/hal+json</stringProp>
                    </elementProp>
                    <elementProp name="" elementType="Header">
                      <stringProp name="Header.name">Accept-Encoding</stringProp>
                      <stringProp name="Header.value">gzip, deflate, br</stringProp>
                    </elementProp>
                    <elementProp name="" elementType="Header">
                      <stringProp name="Header.name">Connection</stringProp>
                      <stringProp name="Header.value">keep-alive</stringProp>
                    </elementProp>
                    <elementProp name="Accept" elementType="Header">
                      <stringProp name="Header.name">Accept</stringProp>
                      <stringProp name="Header.value">*/*</stringProp>
                    </elementProp>
                  </collectionProp>
                </HeaderManager>
                <hashTree/>
              </hashTree>
            </hashTree>
            <TransactionController guiclass="TransactionControllerGui" testclass="TransactionController" testname="Поиск активного ростера" enabled="true">
              <boolProp name="TransactionController.includeTimers">false</boolProp>
              <boolProp name="TransactionController.parent">false</boolProp>
            </TransactionController>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="&gt;_api/v1/org-units/${orgUnitId}/rosters" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="from" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">false</boolProp>
                      <stringProp name="Argument.value">${DATE_START_MONTH}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">from</stringProp>
                    </elementProp>
                    <elementProp name="to" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">false</boolProp>
                      <stringProp name="Argument.value">${DATE_END_MONTH}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">to</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${BASE_URL}</stringProp>
                <stringProp name="HTTPSampler.port"></stringProp>
                <stringProp name="HTTPSampler.protocol">${PROTOCOL}</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/v1/org-units/${orgUnitId}/rosters</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON Active Roster Extractor" enabled="true">
                  <stringProp name="JSONPostProcessor.referenceNames">active_roster_id</stringProp>
                  <stringProp name="JSONPostProcessor.jsonPathExprs">$._embedded.rosters[?(@.active== true)].id</stringProp>
                  <stringProp name="JSONPostProcessor.match_numbers">1</stringProp>
                  <stringProp name="JSONPostProcessor.defaultValues">null</stringProp>
                </JSONPostProcessor>
                <hashTree/>
              </hashTree>
            </hashTree>
            <TransactionController guiclass="TransactionControllerGui" testclass="TransactionController" testname="Получить PositionCategoryRosterId" enabled="true">
              <boolProp name="TransactionController.includeTimers">false</boolProp>
              <boolProp name="TransactionController.parent">false</boolProp>
            </TransactionController>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="&gt;_api/v1/rosters/${active_roster_id}/position-category-rosters" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
                  <collectionProp name="Arguments.arguments"/>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${BASE_URL}</stringProp>
                <stringProp name="HTTPSampler.port"></stringProp>
                <stringProp name="HTTPSampler.protocol">${PROTOCOL}</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/v1/rosters/${active_roster_id}/position-category-rosters</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON Extractor получить ссылку на positionCategoryRosterId" enabled="true">
                  <stringProp name="JSONPostProcessor.referenceNames">linksPositionCategoryRosterId</stringProp>
                  <stringProp name="JSONPostProcessor.jsonPathExprs">$._embedded.positionCategoryRosters[0]._links.self.href </stringProp>
                  <stringProp name="JSONPostProcessor.match_numbers"></stringProp>
                  <stringProp name="JSONPostProcessor.defaultValues">null</stringProp>
                </JSONPostProcessor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="Regular Expression Extractor получить positionCategoryRosterId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">URL</stringProp>
                  <stringProp name="RegexExtractor.refname">positionCategoryRosterId</stringProp>
                  <stringProp name="RegexExtractor.regex">/(\d+)$</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number"></stringProp>
                  <stringProp name="Sample.scope">variable</stringProp>
                  <stringProp name="Scope.variable">linksPositionCategoryRosterId</stringProp>
                </RegexExtractor>
                <hashTree/>
              </hashTree>
            </hashTree>
            <TransactionController guiclass="TransactionControllerGui" testclass="TransactionController" testname="Получить и сохранить значение последнего requestId из бд" enabled="true">
              <boolProp name="TransactionController.includeTimers">false</boolProp>
              <boolProp name="TransactionController.parent">false</boolProp>
            </TransactionController>
            <hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Получить последний requstId" enabled="true">
                <stringProp name="dataSource">db_outstaff</stringProp>
                <stringProp name="query">SELECT id FROM public.request WHERE status = &apos;CREATED&apos;  AND DATE(created) &gt;= (CURRENT_DATE - INTERVAL &apos;1 day&apos;) order by id desc limit 1;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
                <stringProp name="resultSetMaxRows"></stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">last_request_id</stringProp>
              </JDBCSampler>
              <hashTree/>
            </hashTree>
            <TransactionController guiclass="TransactionControllerGui" testclass="TransactionController" testname="Создать пользователя" enabled="true">
              <boolProp name="TransactionController.includeTimers">false</boolProp>
              <boolProp name="TransactionController.parent">false</boolProp>
            </TransactionController>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Получить данные о пользователя на стороннем сайте" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
                  <collectionProp name="Arguments.arguments"/>
                </elementProp>
                <stringProp name="HTTPSampler.domain">api.randomdatatools.ru</stringProp>
                <stringProp name="HTTPSampler.port"></stringProp>
                <stringProp name="HTTPSampler.protocol">https</stringProp>
                <stringProp name="HTTPSampler.contentEncoding">UTF-16</stringProp>
                <stringProp name="HTTPSampler.path"></stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="TestPlan.comments">СНИЛС на сайте не проходит валидацию, когда вводишь рандомные цифры, генерирую данные на сайте</stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON Extractor" enabled="true">
                  <stringProp name="JSONPostProcessor.referenceNames">name;lastname;patronymic;snils;phone;cardNumber;email;</stringProp>
                  <stringProp name="JSONPostProcessor.jsonPathExprs">$.FirstName;$.LastName;$.FatherName;$.snils;$.Phone;$.PasportNumber;$.Email;</stringProp>
                  <stringProp name="JSONPostProcessor.match_numbers"></stringProp>
                  <stringProp name="JSONPostProcessor.defaultValues">Федор;Федоров;Федорович;0;0;7755;good@goodt.me;</stringProp>
                </JSONPostProcessor>
                <hashTree/>
              </hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="&gt;_wfm-cpa/api/employee" enabled="true">
                <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">false</boolProp>
                      <stringProp name="Argument.value">{&#xd;
  &quot;name&quot;: &quot;${name}&quot;,&#xd;
  &quot;surname&quot;: &quot;${lastname}&quot;,&#xd;
  &quot;patronymic&quot;: &quot;${patronymic}&quot;,&#xd;
  &quot;phone&quot;: &quot;+79158887766&quot;,&#xd;
  &quot;phone2&quot;: &quot;+79158887766&quot;,&#xd;
  &quot;email&quot;: &quot;${email}&quot;,&#xd;
  &quot;snils&quot;: &quot;${snils}&quot;,&#xd;
  &quot;date_from&quot;: &quot;${DATE_START_YEAR}&quot;,&#xd;
  &quot;date_to&quot;: &quot;${DATE_NEXT_YEAR}&quot;,&#xd;
  &quot;card_number&quot;: &quot;${cardNumber}&quot;&#xd;
}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${OUTSTAFF_URL}</stringProp>
                <stringProp name="HTTPSampler.port"></stringProp>
                <stringProp name="HTTPSampler.protocol">${PROTOCOL}</stringProp>
                <stringProp name="HTTPSampler.contentEncoding">UTF-8</stringProp>
                <stringProp name="HTTPSampler.path">/wfm-cpa/api/employee</stringProp>
                <stringProp name="HTTPSampler.method">POST</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="TestPlan.comments">создать сотрудника</stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
                  <collectionProp name="HeaderManager.headers">
                    <elementProp name="" elementType="Header">
                      <stringProp name="Header.name">Content-Type</stringProp>
                      <stringProp name="Header.value">application/json</stringProp>
                    </elementProp>
                    <elementProp name="" elementType="Header">
                      <stringProp name="Header.name">Accept-Encoding</stringProp>
                      <stringProp name="Header.value">gzip, deflate, br</stringProp>
                    </elementProp>
                    <elementProp name="" elementType="Header">
                      <stringProp name="Header.name">Connection</stringProp>
                      <stringProp name="Header.value">keep-alive</stringProp>
                    </elementProp>
                    <elementProp name="Accept" elementType="Header">
                      <stringProp name="Header.name">Accept</stringProp>
                      <stringProp name="Header.value">*/*</stringProp>
                    </elementProp>
                    <elementProp name="" elementType="Header">
                      <stringProp name="Header.name">Authorization</stringProp>
                      <stringProp name="Header.value">Bearer ${TOKEN_CP}</stringProp>
                    </elementProp>
                  </collectionProp>
                </HeaderManager>
                <hashTree/>
                <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="Извлечь employee_id" enabled="true">
                  <stringProp name="JSONPostProcessor.referenceNames">employee_id</stringProp>
                  <stringProp name="JSONPostProcessor.jsonPathExprs">$.id;</stringProp>
                  <stringProp name="JSONPostProcessor.match_numbers"></stringProp>
                  <stringProp name="JSONPostProcessor.defaultValues">0</stringProp>
                </JSONPostProcessor>
                <hashTree/>
              </hashTree>
            </hashTree>
            <LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="Создать свободные смены" enabled="true">
              <boolProp name="LoopController.continue_forever">true</boolProp>
              <stringProp name="LoopController.loops">${countShiftOnOm}</stringProp>
            </LoopController>
            <hashTree>
              <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Расчитать даты для свободной смены" enabled="true">
                <stringProp name="scriptLanguage">java</stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="cacheKey">true</stringProp>
                <stringProp name="script">	   import java.time.LocalDate;
	   import java.time.LocalTime;
  	   import java.time.format.DateTimeFormatter;

  	   
        LocalDate date = LocalDate.parse(vars.get(&quot;dateOnShift&quot;));
            String startTime = vars.get(&quot;startTime&quot;);
            String endTime = vars.get(&quot;endTime&quot;);

            // Обновляем startTime и endTime для следующей смены
            LocalTime start = LocalTime.parse(startTime, DateTimeFormatter.ofPattern(&quot;HH:mm:ss.SSSSSS&quot;));
            LocalTime end = LocalTime.parse(endTime, DateTimeFormatter.ofPattern(&quot;HH:mm:ss.SSSSSS&quot;));

            start = start.plusSeconds(360); // Начало следующей смены с учетом 4-минутной смены и 2-минутного перерыва
            end = end.plusSeconds(360); // Конец следующей смены с учетом 4-минутной смены и 2-минутного перерыва

            String startFormat = start.format(DateTimeFormatter.ofPattern(&quot;HH:mm:ss.SSSSSS&quot;));
            String endFormat = end.format(DateTimeFormatter.ofPattern(&quot;HH:mm:ss.SSSSSS&quot;));
            vars.put(&quot;startTime&quot;, startFormat);
            vars.put(&quot;endTime&quot;, endFormat);

            vars.put(&quot;sqlStartTime&quot;, date.toString() + &quot; &quot; + startFormat);
            vars.put(&quot;sqlEndTime&quot;, date.toString() + &quot; &quot; + endFormat);

            // Если достигнут конец текущего дня, переходим на следующий день
            if ((start.getHour() == 0 &amp;&amp; start.getMinute() == 0 &amp;&amp; start.getSecond() == 0) ||
                    (end.getHour() == 0 &amp;&amp; end.getMinute() == 0 &amp;&amp; end.getSecond() == 0)) {
                date = date.plusDays(1);
                vars.put(&quot;dateOnShift&quot;, date.toString());
            }
</stringProp>
              </JSR223Sampler>
              <hashTree/>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Создание свободной смены в базе данных магнита" enabled="true">
                <stringProp name="dataSource">db_magnit</stringProp>
                <stringProp name="query">INSERT INTO public.shift (allow_confirm_exchange, available_for_assignment, enddatetime, startdatetime, edited,
     employee_position_id, lunch, pos_cat_roster_id, position_index, worked_status,
     fte_position_group_id, planned_shift_id, positiontype_id, outstaff, extended_status,
     planned_absence, original_id, vacant_shift_type, exchange_rule_id, outer_id,
     job_title_exchange_id, created, updated, external, breaks,
     exchange_status_id, resolve_time, sub_type, create_mode, bio_status, src_shift_id,
     approve_doc_id, creator_id, agreement_file, return_to_exchange, published,
     version, worked, org_unit_id, shift_template_id
     )
VALUES (false, false, &apos;${sqlEndTime}&apos;, &apos;${sqlStartTime}&apos;, true, 
   null, 0, &apos;${positionCategoryRosterId}&apos;, null, null,
    null, null, null, true, null,
    false, null, null, null, null, 
   2, &apos;${createStart}&apos;, &apos;${createUpdate}&apos;, false, null,
    1, null, null, &apos;ES&apos;, null, null,
   null, 1, null, null, false,
   1, false, &apos;${orgUnitId}&apos;, null);
</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes">timestamp, timestamp, bigint</stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Update Statement</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
                <stringProp name="resultSetMaxRows"></stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames"></stringProp>
              </JDBCSampler>
              <hashTree/>
            </hashTree>
            <TransactionController guiclass="TransactionControllerGui" testclass="TransactionController" testname="Создание свободной смены через api" enabled="true">
              <boolProp name="TransactionController.includeTimers">false</boolProp>
              <stringProp name="TestPlan.comments">Когда мы создаём смены через БД, то график все равно остаётся опубликованным, нужно создать одну смену через api, чтобы ростер поменялся и его можно было опубликовать, для того, чтобы смены ушли на outstaff</stringProp>
              <boolProp name="TransactionController.parent">false</boolProp>
            </TransactionController>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="&gt;_api/v1/shifts" enabled="true">
                <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">false</boolProp>
                      <stringProp name="Argument.value">{&#xd;
  &quot;_links&quot;: {&#xd;
    &quot;jobTitle&quot;: {&#xd;
      &quot;href&quot;: &quot;https://magnit-master.goodt.me/api/v1/job-titles/2&quot;&#xd;
    }&#xd;
  },&#xd;
  &quot;_errors&quot;: {},&#xd;
  &quot;scheduleItemKind&quot;: &quot;SHIFT&quot;,&#xd;
  &quot;startDate&quot;: &quot;${DATE_NOW}&quot;,&#xd;
  &quot;endDate&quot;: &quot;${DATE_NOW}&quot;,&#xd;
  &quot;repeatRule&quot;: {&#xd;
    &quot;periodicity&quot;: &quot;NO_REPEAT&quot;,&#xd;
    &quot;name&quot;: &quot;Не повторять&quot;&#xd;
  },&#xd;
  &quot;orgUnit&quot;: {&#xd;
    &quot;availableForCalculation&quot;: true,&#xd;
    &quot;availableForStaffingCalculation&quot;: true,&#xd;
    &quot;active&quot;: true,&#xd;
    &quot;_links&quot;: {&#xd;
    },&#xd;
    &quot;id&quot;: ${orgUnitId}&#xd;
  },&#xd;
  &quot;jobTitle&quot;: &quot;Директор магазина&quot;,&#xd;
  &quot;lunch&quot;: 0,&#xd;
  &quot;commentText&quot;: &quot;тест&quot;,&#xd;
  &quot;hiringReasonText&quot;: &quot;Усиление директора&quot;,&#xd;
  &quot;additionalWorks&quot;: [],&#xd;
  &quot;rosterId&quot;: ${active_roster_id},&#xd;
  &quot;statusName_&quot;: &quot;Смена&quot;,&#xd;
  &quot;partners&quot;: [],&#xd;
  &quot;necessaryAddWorkIds&quot;: [],&#xd;
  &quot;originalAdditionalWorks&quot;: [],&#xd;
  &quot;dateTimeInterval&quot;: {&#xd;
    &quot;startDateTime&quot;: &quot;${tStart}&quot;,&#xd;
    &quot;endDateTime&quot;: &quot;${tEnd}&quot;&#xd;
  },&#xd;
  &quot;positionCategoryRosterId&quot;: ${positionCategoryRosterId}&#xd;
}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${BASE_URL}</stringProp>
                <stringProp name="HTTPSampler.port"></stringProp>
                <stringProp name="HTTPSampler.protocol">${PROTOCOL}</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">api/v1/shifts</stringProp>
                <stringProp name="HTTPSampler.method">POST</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
                  <collectionProp name="HeaderManager.headers">
                    <elementProp name="" elementType="Header">
                      <stringProp name="Header.name">Content-Type</stringProp>
                      <stringProp name="Header.value">application/hal+json</stringProp>
                    </elementProp>
                    <elementProp name="" elementType="Header">
                      <stringProp name="Header.name">Accept-Encoding</stringProp>
                      <stringProp name="Header.value">gzip, deflate, br</stringProp>
                    </elementProp>
                    <elementProp name="" elementType="Header">
                      <stringProp name="Header.name">Connection</stringProp>
                      <stringProp name="Header.value">keep-alive</stringProp>
                    </elementProp>
                    <elementProp name="Accept" elementType="Header">
                      <stringProp name="Header.name">Accept</stringProp>
                      <stringProp name="Header.value">*/*</stringProp>
                    </elementProp>
                  </collectionProp>
                </HeaderManager>
                <hashTree/>
              </hashTree>
            </hashTree>
            <TransactionController guiclass="TransactionControllerGui" testclass="TransactionController" testname="Отправить график на публикацию" enabled="true">
              <boolProp name="TransactionController.includeTimers">false</boolProp>
              <boolProp name="TransactionController.parent">false</boolProp>
            </TransactionController>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="&gt;_api/v1/org-units/${orgUnitId}/rosters" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="from" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">false</boolProp>
                      <stringProp name="Argument.value">${DATE_START_MONTH}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">from</stringProp>
                    </elementProp>
                    <elementProp name="to" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">false</boolProp>
                      <stringProp name="Argument.value">${DATE_END_MONTH}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">to</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${BASE_URL}</stringProp>
                <stringProp name="HTTPSampler.port"></stringProp>
                <stringProp name="HTTPSampler.protocol">${PROTOCOL}</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/v1/org-units/${orgUnitId}/rosters</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON Active Roster Extractor" enabled="true">
                  <stringProp name="JSONPostProcessor.referenceNames">new_active_roster_id</stringProp>
                  <stringProp name="JSONPostProcessor.jsonPathExprs">$._embedded.rosters[?(@.active== true)].id</stringProp>
                  <stringProp name="JSONPostProcessor.match_numbers">1</stringProp>
                  <stringProp name="JSONPostProcessor.defaultValues">null</stringProp>
                </JSONPostProcessor>
                <hashTree/>
              </hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="&gt;_api/v1/rosters/${active_roster_id}/publish?force=false" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="active" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">false</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">active</stringProp>
                    </elementProp>
                    <elementProp name="publish" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">false</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">publish</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${BASE_URL}</stringProp>
                <stringProp name="HTTPSampler.port"></stringProp>
                <stringProp name="HTTPSampler.protocol">${PROTOCOL}</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/v1/rosters/${new_active_roster_id}/publish?force=false</stringProp>
                <stringProp name="HTTPSampler.method">PUT</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="TestPlan.comments">https://magnitqa-wfm.goodt.me/api/v1/rosters/8129709/publish?force=false</stringProp>
              </HTTPSamplerProxy>
              <hashTree/>
            </hashTree>
            <TransactionController guiclass="TransactionControllerGui" testclass="TransactionController" testname="Получить все requestId" enabled="true">
              <boolProp name="TransactionController.includeTimers">false</boolProp>
              <boolProp name="TransactionController.parent">false</boolProp>
            </TransactionController>
            <hashTree>
              <TestAction guiclass="TestActionGui" testclass="TestAction" testname="FCA_5-6m" enabled="false">
                <intProp name="ActionProcessor.action">1</intProp>
                <intProp name="ActionProcessor.target">0</intProp>
                <stringProp name="ActionProcessor.duration">${__Random(300000,360000,)}</stringProp>
              </TestAction>
              <hashTree/>
              <TestAction guiclass="TestActionGui" testclass="TestAction" testname="FCA_1m" enabled="true">
                <intProp name="ActionProcessor.action">1</intProp>
                <intProp name="ActionProcessor.target">0</intProp>
                <stringProp name="ActionProcessor.duration">${__Random(65000,80000,)}</stringProp>
              </TestAction>
              <hashTree/>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Получить все requstId" enabled="true">
                <stringProp name="dataSource">db_outstaff</stringProp>
                <stringProp name="query">SELECT id FROM public.request WHERE id &gt; ${last_request_id_1} AND status = &apos;CREATED&apos;  AND DATE(created) &gt;= (CURRENT_DATE - INTERVAL &apos;1 day&apos;);</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout">60</stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
                <stringProp name="resultSetMaxRows"></stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">REQUEST_ID</stringProp>
              </JDBCSampler>
              <hashTree/>
            </hashTree>
            <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Записать пользователя в csv файл" enabled="true">
              <stringProp name="cacheKey">true</stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="script">import org.apache.commons.lang3.RandomStringUtils;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

String filePath = &quot;values.csv&quot;;
Integer value = Integer.parseInt(vars.get(&quot;REQUEST_ID_#&quot;));

FileWriter fw = null;
try {
    fw = new FileWriter(filePath, true);
    File file = new File(filePath);
    if (file.length() == 0) {
        fw.write(&quot;employeeId,requestId,omId\n&quot;);
    }

    for (int a = 1; a &lt;= value; a++) {
    	   String variable = &quot;REQUEST_ID_&quot; + a;
        fw.write(vars.get(&quot;employee_id&quot;) + &quot;,&quot; + vars.get(variable) + &quot;,&quot; + vars.get(&quot;orgUnitId&quot;) + &quot;\n&quot;);
    }
    fw.close();
} catch (IOException e) {
    e.printStackTrace();
}

</stringProp>
              <stringProp name="scriptLanguage">java</stringProp>
            </JSR223Sampler>
            <hashTree/>
            <DebugSampler guiclass="TestBeanGUI" testclass="DebugSampler" testname="Debug Sampler" enabled="true">
              <boolProp name="displayJMeterProperties">false</boolProp>
              <boolProp name="displayJMeterVariables">true</boolProp>
              <boolProp name="displaySystemProperties">false</boolProp>
            </DebugSampler>
            <hashTree/>
          </hashTree>
        </hashTree>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="4. Создать свободные смены у подразделения и собрать CSV файл с данными смены (1 минуты интервал одной свободной смены)" enabled="false">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
      </ThreadGroup>
      <hashTree>
        <TransactionController guiclass="TransactionControllerGui" testclass="TransactionController" testname="Авторизация SVP" enabled="true">
          <boolProp name="TransactionController.includeTimers">false</boolProp>
          <boolProp name="TransactionController.parent">false</boolProp>
        </TransactionController>
        <hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="&gt;_/wfm-cpa/login" enabled="true">
            <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
              <collectionProp name="Arguments.arguments">
                <elementProp name="" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value">{&#xd;
  &quot;username&quot;: &quot;svp&quot;,&#xd;
  &quot;password&quot;: &quot;svp&quot;&#xd;
}</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
            <stringProp name="HTTPSampler.domain">${OUTSTAFF_URL}</stringProp>
            <stringProp name="HTTPSampler.port"></stringProp>
            <stringProp name="HTTPSampler.protocol">${PROTOCOL}</stringProp>
            <stringProp name="HTTPSampler.contentEncoding">UTF-16</stringProp>
            <stringProp name="HTTPSampler.path">/wfm-cpa/login</stringProp>
            <stringProp name="HTTPSampler.method">POST</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
            <stringProp name="HTTPSampler.response_timeout"></stringProp>
          </HTTPSamplerProxy>
          <hashTree>
            <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
              <collectionProp name="HeaderManager.headers">
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Content-Type</stringProp>
                  <stringProp name="Header.value">application/json</stringProp>
                </elementProp>
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Accept-Encoding</stringProp>
                  <stringProp name="Header.value">gzip, deflate, br</stringProp>
                </elementProp>
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Connection</stringProp>
                  <stringProp name="Header.value">keep-alive</stringProp>
                </elementProp>
                <elementProp name="Accept" elementType="Header">
                  <stringProp name="Header.name">Accept</stringProp>
                  <stringProp name="Header.value">*/*</stringProp>
                </elementProp>
              </collectionProp>
            </HeaderManager>
            <hashTree/>
            <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="Regular Expression Extractor" enabled="true">
              <stringProp name="RegexExtractor.useHeaders">true</stringProp>
              <stringProp name="RegexExtractor.refname">TOKEN</stringProp>
              <stringProp name="RegexExtractor.regex">Authorization: (.+).</stringProp>
              <stringProp name="RegexExtractor.template">$1$</stringProp>
              <stringProp name="RegexExtractor.default"></stringProp>
              <stringProp name="RegexExtractor.match_number"></stringProp>
            </RegexExtractor>
            <hashTree/>
          </hashTree>
          <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Преобразовать строку в TOKEN" enabled="true">
            <stringProp name="scriptLanguage">java</stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="cacheKey">true</stringProp>
            <stringProp name="script">String token = vars.get(&quot;TOKEN_g0&quot;); // Почему то TOKEN он не весь достаётся, приходится вытаскивать из TOKEN_g0
int startIndex = token.indexOf(&quot;Authorization: &quot;) + &quot;Authorization: &quot;.length();
String extractedToken = token.substring(startIndex);
vars.put(&quot;TOKEN&quot;, extractedToken);</stringProp>
          </JSR223Sampler>
          <hashTree/>
        </hashTree>
        <BeanShellSampler guiclass="BeanShellSamplerGui" testclass="BeanShellSampler" testname="Dates" enabled="true">
          <stringProp name="BeanShellSampler.query">import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;


LocalDate date = LocalDate.now();
String dateToday = String.valueOf(date);
String dateStart = String.valueOf(date.withDayOfMonth(1));
String dateEnd = String.valueOf(date.withDayOfMonth(date.lengthOfMonth()));
String dateMonthAgo = String.valueOf(date.minusMonths(1));
String dateNextYear = String.valueOf(date.plusYears(1));
String dateStartYear = String.valueOf(date.withDayOfYear(1));
String dateYesterday = &quot;&quot;;

String dateNow = String.valueOf(LocalDate.now());
String end = dateNow +&quot; 18:05:00.000000&quot;;
String start = dateNow +&quot; 09:05:00.000000&quot;;
String createStart = dateNow +&quot; 03:33:00.000000&quot;;
String createUpdate = dateNow + &quot; 03:34:00.000000&quot;;
String tStart = dateNow + &quot;T09:05:00&quot;;
String tEnd = dateNow + &quot;T18:05:00&quot;;
vars.put(&quot;dend&quot;, end);
vars.put(&quot;dstart&quot;, start);
vars.put(&quot;createStart&quot;, createStart);
vars.put(&quot;createUpdate&quot;, createUpdate);
vars.put(&quot;tStart&quot;, tStart);
vars.put(&quot;tEnd&quot;, tEnd);

if (date.equals(date.withDayOfMonth(1))) {
	dateYesterday = dateToday;
} else {
	dateYesterday = String.valueOf(date.minusDays(1));
}
vars.put(&quot;DATE_NOW&quot;, dateToday);
vars.put(&quot;DATE_START_MONTH&quot;, dateStart);
vars.put(&quot;DATE_END_MONTH&quot;, dateEnd);
vars.put(&quot;DATE_MONTH_AGO&quot;, dateMonthAgo);
vars.put(&quot;DATE_YESTERDAY&quot;, dateYesterday);
vars.put(&quot;DATE_NEXT_YEAR&quot;, dateNextYear);
vars.put(&quot;DATE_START_YEAR&quot;, dateStartYear);

List datesToMonthEnd = new ArrayList();
LocalDate endOfMonth = date.withDayOfMonth(date.lengthOfMonth());
datesToMonthEnd.add(date.toString());
while (!endOfMonth.equals(date)) {
	datesToMonthEnd.add(endOfMonth.toString());
	endOfMonth = endOfMonth.minusDays(1);
}
int counter = 1;
for (int i = 0 ; i &lt; datesToMonthEnd.size(); i++) {
	String varName = &quot;varDates_&quot;+String.valueOf(counter);
	counter+=1;
	vars.put(varName, datesToMonthEnd.get(i));	
}
vars.put(&quot;varCounter&quot;, String.valueOf(datesToMonthEnd.size()));
        </stringProp>
          <stringProp name="BeanShellSampler.filename"></stringProp>
          <stringProp name="BeanShellSampler.parameters"></stringProp>
          <boolProp name="BeanShellSampler.resetInterpreter">false</boolProp>
        </BeanShellSampler>
        <hashTree/>
        <TransactionController guiclass="TransactionControllerGui" testclass="TransactionController" testname="Авторизация CP" enabled="true">
          <boolProp name="TransactionController.includeTimers">false</boolProp>
          <boolProp name="TransactionController.parent">false</boolProp>
        </TransactionController>
        <hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="&gt;_/wfm-cpa/login" enabled="true">
            <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
              <collectionProp name="Arguments.arguments">
                <elementProp name="" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value">{&#xd;
  &quot;username&quot;: &quot;s.khoroshkov@gmail.com&quot;,&#xd;
  &quot;password&quot;: &quot;goodtme&quot;&#xd;
}</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
            <stringProp name="HTTPSampler.domain">${OUTSTAFF_URL}</stringProp>
            <stringProp name="HTTPSampler.port"></stringProp>
            <stringProp name="HTTPSampler.protocol">${PROTOCOL}</stringProp>
            <stringProp name="HTTPSampler.contentEncoding">UTF-16</stringProp>
            <stringProp name="HTTPSampler.path">/wfm-cpa/login</stringProp>
            <stringProp name="HTTPSampler.method">POST</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
            <stringProp name="HTTPSampler.response_timeout"></stringProp>
          </HTTPSamplerProxy>
          <hashTree>
            <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
              <collectionProp name="HeaderManager.headers">
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Content-Type</stringProp>
                  <stringProp name="Header.value">application/json</stringProp>
                </elementProp>
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Accept-Encoding</stringProp>
                  <stringProp name="Header.value">gzip, deflate, br</stringProp>
                </elementProp>
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Connection</stringProp>
                  <stringProp name="Header.value">keep-alive</stringProp>
                </elementProp>
                <elementProp name="Accept" elementType="Header">
                  <stringProp name="Header.name">Accept</stringProp>
                  <stringProp name="Header.value">*/*</stringProp>
                </elementProp>
              </collectionProp>
            </HeaderManager>
            <hashTree/>
            <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="Regular Expression Extractor" enabled="true">
              <stringProp name="RegexExtractor.useHeaders">true</stringProp>
              <stringProp name="RegexExtractor.refname">TOKEN_CP</stringProp>
              <stringProp name="RegexExtractor.regex">Authorization: (.+).</stringProp>
              <stringProp name="RegexExtractor.template">$1$</stringProp>
              <stringProp name="RegexExtractor.default"></stringProp>
              <stringProp name="RegexExtractor.match_number"></stringProp>
            </RegexExtractor>
            <hashTree/>
          </hashTree>
          <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Преобразовать строку в TOKEN" enabled="true">
            <stringProp name="scriptLanguage">java</stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="cacheKey">true</stringProp>
            <stringProp name="script">String token = vars.get(&quot;TOKEN_CP_g0&quot;); // Почему то TOKEN он не весь достаётся, приходится вытаскивать из TOKEN_g0
int startIndex = token.indexOf(&quot;Authorization: &quot;) + &quot;Authorization: &quot;.length();
String extractedToken = token.substring(startIndex);
vars.put(&quot;TOKEN_CP&quot;, extractedToken);</stringProp>
          </JSR223Sampler>
          <hashTree/>
        </hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Расчитать, сколько потребуется подразделений и свободных смен в них" enabled="true">
          <stringProp name="scriptLanguage">java</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">	   import java.time.LocalDate;
	   import java.time.temporal.TemporalAdjusters;
	   
	   int totalShiftsNeeded = Integer.valueOf(vars.get(&quot;count_free_shifts&quot;));
        int shiftsPerDay = 720; // 1440 минут в сутках / 2 минуты на смену
        vars.put(&quot;shiftsPerDay&quot;, String.valueOf(shiftsPerDay));

        LocalDate today = LocalDate.now();
        LocalDate endOfMonth = today.with(TemporalAdjusters.lastDayOfMonth());
        int remainingDays = endOfMonth.getDayOfMonth() - today.getDayOfMonth() + 1; //Оставшееся количество дней в этом месяце

        int shiftsThisMonthPerDivision = shiftsPerDay * remainingDays; //Смены, которые можно создать в одном подразделении
        int requiredDivisions = (int) Math.ceil((double) totalShiftsNeeded / shiftsThisMonthPerDivision); //Необходимое количество подразделений

        if (shiftsThisMonthPerDivision &gt; totalShiftsNeeded){
            shiftsThisMonthPerDivision = totalShiftsNeeded;
        }
        vars.put(&quot;shiftsThisMonthPerDivision&quot;, String.valueOf(shiftsThisMonthPerDivision));
        vars.put(&quot;requiredDivisions&quot;, String.valueOf(requiredDivisions));</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Очистить csv файл" enabled="true">
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="script">import org.apache.commons.lang3.RandomStringUtils;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

String filePath = &quot;values2.csv&quot;;

    try {
	
	FileWriter fw = new FileWriter(filePath, false); 
	fw.close();
    } 
    catch (IOException e) {
        e.printStackTrace().toString();
    }
</stringProp>
          <stringProp name="scriptLanguage">java</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Получить все оргюниты с магнита" enabled="true">
          <stringProp name="dataSource">db_magnit</stringProp>
          <stringProp name="query">SELECT DISTINCT o.id
FROM organizationunit o
JOIN roster r ON o.id = r.org_unit_id
JOIN entity_property_org_unit epou ON o.id = epou.org_unit_id
JOIN entity_property_value epv ON epou.value_id = epv.id
WHERE availableforcalculation = true and o.id &gt; 0
LIMIT ${requiredDivisions}</stringProp>
          <stringProp name="queryArguments"></stringProp>
          <stringProp name="queryArgumentsTypes"></stringProp>
          <stringProp name="queryTimeout"></stringProp>
          <stringProp name="queryType">Select Statement</stringProp>
          <stringProp name="resultSetHandler">Store as String</stringProp>
          <stringProp name="resultSetMaxRows"></stringProp>
          <stringProp name="resultVariable"></stringProp>
          <stringProp name="variableNames">orgUnitsId</stringProp>
        </JDBCSampler>
        <hashTree/>
        <TransactionController guiclass="TransactionControllerGui" testclass="TransactionController" testname="Выключить настройку публикации графиков с конфликтами" enabled="true">
          <boolProp name="TransactionController.includeTimers">false</boolProp>
          <boolProp name="TransactionController.parent">false</boolProp>
        </TransactionController>
        <hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="&gt;_api/v1/system-properties/124" enabled="true">
            <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
              <collectionProp name="Arguments.arguments">
                <elementProp name="" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value">{&#xd;
  &quot;enabled&quot;: true,&#xd;
  &quot;key&quot;: &quot;roster.publish.without_conflicts&quot;,&#xd;
  &quot;title&quot;: &quot;Публикация без конфликтов&quot;,&#xd;
  &quot;description&quot;: &quot;Публикация расписания только без конфликтов&quot;,&#xd;
  &quot;value&quot;: false,&#xd;
  &quot;type&quot;: &quot;BACK&quot;,&#xd;
  &quot;dataType&quot;: &quot;BOOL&quot;,&#xd;
  &quot;tags&quot;: [&#xd;
    &quot;Публикация расписания&quot;&#xd;
  ],&#xd;
  &quot;created&quot;: &quot;2021-03-17T15:39:21.3073&quot;,&#xd;
  &quot;updated&quot;: &quot;2023-11-08T08:10:29.636474&quot;,&#xd;
  &quot;_links&quot;: {&#xd;
    &quot;self&quot;: {&#xd;
      &quot;href&quot;: &quot;https://goodt-pochta-loadqa.goodt.me/api/v1/system-properties/124&quot;&#xd;
    }&#xd;
  },&#xd;
  &quot;id&quot;: null&#xd;
}</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
            <stringProp name="HTTPSampler.domain">${BASE_URL}</stringProp>
            <stringProp name="HTTPSampler.port"></stringProp>
            <stringProp name="HTTPSampler.protocol">${PROTOCOL}</stringProp>
            <stringProp name="HTTPSampler.contentEncoding"></stringProp>
            <stringProp name="HTTPSampler.path">api/v1/system-properties/124</stringProp>
            <stringProp name="HTTPSampler.method">PUT</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
            <stringProp name="HTTPSampler.response_timeout"></stringProp>
          </HTTPSamplerProxy>
          <hashTree>
            <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
              <collectionProp name="HeaderManager.headers">
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Content-Type</stringProp>
                  <stringProp name="Header.value">application/hal+json</stringProp>
                </elementProp>
              </collectionProp>
            </HeaderManager>
            <hashTree/>
          </hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="&gt;_api/v1/system-properties/370" enabled="true">
            <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
              <collectionProp name="Arguments.arguments">
                <elementProp name="" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value">{&#xd;
    &quot;enabled&quot;: true,&#xd;
    &quot;key&quot;: &quot;roster.single_edited_version&quot;,&#xd;
    &quot;title&quot;: &quot;\&quot;Редактируемая\&quot; версия ростера может быть только одна&quot;,&#xd;
    &quot;description&quot;: &quot;При попытке отредактировать опубликованный/расчётный ростер, возникает ошибка, если он бы отредактирован ранее и уже есть другая, \&quot;редактируемая\&quot; версия&quot;,&#xd;
    &quot;value&quot;: false,&#xd;
    &quot;type&quot;: &quot;BOTH&quot;,&#xd;
    &quot;dataType&quot;: &quot;BOOL&quot;,&#xd;
    &quot;tags&quot;: [&#xd;
        &quot;Версии расписания&quot;&#xd;
    ],&#xd;
    &quot;created&quot;: &quot;2021-10-26T07:59:37.047597&quot;,&#xd;
    &quot;updated&quot;: &quot;2024-01-15T08:32:22.018546&quot;,&#xd;
    &quot;_links&quot;: {&#xd;
        &quot;self&quot;: {&#xd;
            &quot;href&quot;: &quot;https://magnit-master.goodt.me/api/v1/system-properties/370&quot;&#xd;
        }&#xd;
    },&#xd;
    &quot;id&quot;: null&#xd;
}</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
            <stringProp name="HTTPSampler.domain">${BASE_URL}</stringProp>
            <stringProp name="HTTPSampler.port"></stringProp>
            <stringProp name="HTTPSampler.protocol">${PROTOCOL}</stringProp>
            <stringProp name="HTTPSampler.contentEncoding"></stringProp>
            <stringProp name="HTTPSampler.path">api/v1/system-properties/124</stringProp>
            <stringProp name="HTTPSampler.method">PUT</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
            <stringProp name="HTTPSampler.response_timeout"></stringProp>
          </HTTPSamplerProxy>
          <hashTree>
            <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
              <collectionProp name="HeaderManager.headers">
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Content-Type</stringProp>
                  <stringProp name="Header.value">application/hal+json</stringProp>
                </elementProp>
              </collectionProp>
            </HeaderManager>
            <hashTree/>
          </hashTree>
        </hashTree>
        <DebugSampler guiclass="TestBeanGUI" testclass="DebugSampler" testname="Debug Sampler" enabled="true">
          <boolProp name="displayJMeterProperties">false</boolProp>
          <boolProp name="displayJMeterVariables">true</boolProp>
          <boolProp name="displaySystemProperties">false</boolProp>
        </DebugSampler>
        <hashTree/>
        <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach Controller" enabled="true">
          <stringProp name="TestPlan.comments">Добавить в каждый оргюнит свободные смены</stringProp>
          <stringProp name="ForeachController.inputVal">orgUnitsId</stringProp>
          <stringProp name="ForeachController.returnVal">orgUnitId</stringProp>
          <boolProp name="ForeachController.useSeparator">true</boolProp>
          <stringProp name="ForeachController.startIndex">0</stringProp>
          <stringProp name="ForeachController.endIndex">${orgUnitsId_#}</stringProp>
        </ForeachController>
        <hashTree>
          <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Сохранить текущую дату" enabled="true">
            <stringProp name="scriptLanguage">java</stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="cacheKey">true</stringProp>
            <stringProp name="script">	   import java.time.LocalDate;

	   LocalDate date = LocalDate.now();
	   vars.put(&quot;dateOnShift&quot;, date.toString());
	   vars.put(&quot;startTime&quot;, &quot;00:00:00.000000&quot;);
        vars.put(&quot;endTime&quot;, &quot;00:03:00.000000&quot;); // Начнем с интервала 1 минута

  	   </stringProp>
          </JSR223Sampler>
          <hashTree/>
          <DebugSampler guiclass="TestBeanGUI" testclass="DebugSampler" testname="DEBUG после сохранения дат" enabled="true">
            <boolProp name="displayJMeterProperties">false</boolProp>
            <boolProp name="displayJMeterVariables">true</boolProp>
            <boolProp name="displaySystemProperties">false</boolProp>
          </DebugSampler>
          <hashTree/>
          <LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
            <boolProp name="LoopController.continue_forever">true</boolProp>
            <stringProp name="LoopController.loops">${countsUsersOnOM}</stringProp>
          </LoopController>
          <hashTree>
            <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Увеличить количество пользователей" enabled="true">
              <stringProp name="scriptLanguage">java</stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="cacheKey">true</stringProp>
              <stringProp name="script">int countShifts = Integer.valueOf(vars.get(&quot;shiftsThisMonthPerDivision&quot;));
int countShiftOnOm = countShifts / Integer.valueOf(vars.get(&quot;countsUsersOnOM&quot;));
vars.put(&quot;countShiftOnOm&quot;, String.valueOf(countShiftOnOm));
</stringProp>
            </JSR223Sampler>
            <hashTree/>
            <DebugSampler guiclass="TestBeanGUI" testclass="DebugSampler" testname="DEBUG после пользователей" enabled="true">
              <boolProp name="displayJMeterProperties">false</boolProp>
              <boolProp name="displayJMeterVariables">true</boolProp>
              <boolProp name="displaySystemProperties">false</boolProp>
            </DebugSampler>
            <hashTree/>
            <TransactionController guiclass="TransactionControllerGui" testclass="TransactionController" testname="Создать пустой ростер" enabled="true">
              <boolProp name="TransactionController.includeTimers">false</boolProp>
              <boolProp name="TransactionController.parent">false</boolProp>
            </TransactionController>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="&gt;_jobapp/cron-jobs/sys/create-empty-planned-roster" enabled="true">
                <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">false</boolProp>
                      <stringProp name="Argument.value"> {&quot;date&quot;:&quot;${DATE_NOW}&quot;,&quot;orgUnitSelf&quot;:[${orgUnitId}]}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${BASE_URL}</stringProp>
                <stringProp name="HTTPSampler.port"></stringProp>
                <stringProp name="HTTPSampler.protocol">${PROTOCOL}</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/jobapp/cron-jobs/sys/create-empty-planned-roster</stringProp>
                <stringProp name="HTTPSampler.method">POST</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
                  <collectionProp name="HeaderManager.headers">
                    <elementProp name="" elementType="Header">
                      <stringProp name="Header.name">Content-Type</stringProp>
                      <stringProp name="Header.value">application/hal+json</stringProp>
                    </elementProp>
                    <elementProp name="" elementType="Header">
                      <stringProp name="Header.name">Accept-Encoding</stringProp>
                      <stringProp name="Header.value">gzip, deflate, br</stringProp>
                    </elementProp>
                    <elementProp name="" elementType="Header">
                      <stringProp name="Header.name">Connection</stringProp>
                      <stringProp name="Header.value">keep-alive</stringProp>
                    </elementProp>
                    <elementProp name="Accept" elementType="Header">
                      <stringProp name="Header.name">Accept</stringProp>
                      <stringProp name="Header.value">*/*</stringProp>
                    </elementProp>
                  </collectionProp>
                </HeaderManager>
                <hashTree/>
              </hashTree>
            </hashTree>
            <TransactionController guiclass="TransactionControllerGui" testclass="TransactionController" testname="Поиск активного ростера" enabled="true">
              <boolProp name="TransactionController.includeTimers">false</boolProp>
              <boolProp name="TransactionController.parent">false</boolProp>
            </TransactionController>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="&gt;_api/v1/org-units/${orgUnitId}/rosters" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="from" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">false</boolProp>
                      <stringProp name="Argument.value">${DATE_START_MONTH}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">from</stringProp>
                    </elementProp>
                    <elementProp name="to" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">false</boolProp>
                      <stringProp name="Argument.value">${DATE_END_MONTH}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">to</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${BASE_URL}</stringProp>
                <stringProp name="HTTPSampler.port"></stringProp>
                <stringProp name="HTTPSampler.protocol">${PROTOCOL}</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/v1/org-units/${orgUnitId}/rosters</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON Active Roster Extractor" enabled="true">
                  <stringProp name="JSONPostProcessor.referenceNames">active_roster_id</stringProp>
                  <stringProp name="JSONPostProcessor.jsonPathExprs">$._embedded.rosters[?(@.active== true)].id</stringProp>
                  <stringProp name="JSONPostProcessor.match_numbers">1</stringProp>
                  <stringProp name="JSONPostProcessor.defaultValues">null</stringProp>
                </JSONPostProcessor>
                <hashTree/>
              </hashTree>
            </hashTree>
            <TransactionController guiclass="TransactionControllerGui" testclass="TransactionController" testname="Получить PositionCategoryRosterId" enabled="true">
              <boolProp name="TransactionController.includeTimers">false</boolProp>
              <boolProp name="TransactionController.parent">false</boolProp>
            </TransactionController>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="&gt;_api/v1/rosters/${active_roster_id}/position-category-rosters" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
                  <collectionProp name="Arguments.arguments"/>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${BASE_URL}</stringProp>
                <stringProp name="HTTPSampler.port"></stringProp>
                <stringProp name="HTTPSampler.protocol">${PROTOCOL}</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/v1/rosters/${active_roster_id}/position-category-rosters</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON Extractor получить ссылку на positionCategoryRosterId" enabled="true">
                  <stringProp name="JSONPostProcessor.referenceNames">linksPositionCategoryRosterId</stringProp>
                  <stringProp name="JSONPostProcessor.jsonPathExprs">$._embedded.positionCategoryRosters[0]._links.self.href </stringProp>
                  <stringProp name="JSONPostProcessor.match_numbers"></stringProp>
                  <stringProp name="JSONPostProcessor.defaultValues">null</stringProp>
                </JSONPostProcessor>
                <hashTree/>
                <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="Regular Expression Extractor получить positionCategoryRosterId" enabled="true">
                  <stringProp name="RegexExtractor.useHeaders">URL</stringProp>
                  <stringProp name="RegexExtractor.refname">positionCategoryRosterId</stringProp>
                  <stringProp name="RegexExtractor.regex">/(\d+)$</stringProp>
                  <stringProp name="RegexExtractor.template">$1$</stringProp>
                  <stringProp name="RegexExtractor.default">null</stringProp>
                  <stringProp name="RegexExtractor.match_number"></stringProp>
                  <stringProp name="Sample.scope">variable</stringProp>
                  <stringProp name="Scope.variable">linksPositionCategoryRosterId</stringProp>
                </RegexExtractor>
                <hashTree/>
              </hashTree>
            </hashTree>
            <TransactionController guiclass="TransactionControllerGui" testclass="TransactionController" testname="Получить и сохранить значение последнего requestId из бд" enabled="true">
              <boolProp name="TransactionController.includeTimers">false</boolProp>
              <boolProp name="TransactionController.parent">false</boolProp>
            </TransactionController>
            <hashTree>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Получить последний requstId" enabled="true">
                <stringProp name="dataSource">db_outstaff</stringProp>
                <stringProp name="query">SELECT id FROM public.request WHERE status = &apos;CREATED&apos;  AND DATE(created) &gt;= (CURRENT_DATE - INTERVAL &apos;1 day&apos;) order by id desc limit 1;</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
                <stringProp name="resultSetMaxRows"></stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">last_request_id</stringProp>
              </JDBCSampler>
              <hashTree/>
            </hashTree>
            <TransactionController guiclass="TransactionControllerGui" testclass="TransactionController" testname="Создать пользователя" enabled="true">
              <boolProp name="TransactionController.includeTimers">false</boolProp>
              <boolProp name="TransactionController.parent">false</boolProp>
            </TransactionController>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Получить данные о пользователя на стороннем сайте" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
                  <collectionProp name="Arguments.arguments"/>
                </elementProp>
                <stringProp name="HTTPSampler.domain">api.randomdatatools.ru</stringProp>
                <stringProp name="HTTPSampler.port"></stringProp>
                <stringProp name="HTTPSampler.protocol">https</stringProp>
                <stringProp name="HTTPSampler.contentEncoding">UTF-16</stringProp>
                <stringProp name="HTTPSampler.path"></stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="TestPlan.comments">СНИЛС на сайте не проходит валидацию, когда вводишь рандомные цифры, генерирую данные на сайте</stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON Extractor" enabled="true">
                  <stringProp name="JSONPostProcessor.referenceNames">name;lastname;patronymic;snils;phone;cardNumber;email;</stringProp>
                  <stringProp name="JSONPostProcessor.jsonPathExprs">$.FirstName;$.LastName;$.FatherName;$.snils;$.Phone;$.PasportNumber;$.Email;</stringProp>
                  <stringProp name="JSONPostProcessor.match_numbers"></stringProp>
                  <stringProp name="JSONPostProcessor.defaultValues">Федор;Федоров;Федорович;0;0;7755;good@goodt.me;</stringProp>
                </JSONPostProcessor>
                <hashTree/>
              </hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="&gt;_wfm-cpa/api/employee" enabled="true">
                <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">false</boolProp>
                      <stringProp name="Argument.value">{&#xd;
  &quot;name&quot;: &quot;${name}&quot;,&#xd;
  &quot;surname&quot;: &quot;${lastname}&quot;,&#xd;
  &quot;patronymic&quot;: &quot;${patronymic}&quot;,&#xd;
  &quot;phone&quot;: &quot;+79158887766&quot;,&#xd;
  &quot;phone2&quot;: &quot;+79158887766&quot;,&#xd;
  &quot;email&quot;: &quot;${email}&quot;,&#xd;
  &quot;snils&quot;: &quot;${snils}&quot;,&#xd;
  &quot;date_from&quot;: &quot;${DATE_START_YEAR}&quot;,&#xd;
  &quot;date_to&quot;: &quot;${DATE_NEXT_YEAR}&quot;,&#xd;
  &quot;card_number&quot;: &quot;${cardNumber}&quot;&#xd;
}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${OUTSTAFF_URL}</stringProp>
                <stringProp name="HTTPSampler.port"></stringProp>
                <stringProp name="HTTPSampler.protocol">${PROTOCOL}</stringProp>
                <stringProp name="HTTPSampler.contentEncoding">UTF-8</stringProp>
                <stringProp name="HTTPSampler.path">/wfm-cpa/api/employee</stringProp>
                <stringProp name="HTTPSampler.method">POST</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="TestPlan.comments">создать сотрудника</stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
                  <collectionProp name="HeaderManager.headers">
                    <elementProp name="" elementType="Header">
                      <stringProp name="Header.name">Content-Type</stringProp>
                      <stringProp name="Header.value">application/json</stringProp>
                    </elementProp>
                    <elementProp name="" elementType="Header">
                      <stringProp name="Header.name">Accept-Encoding</stringProp>
                      <stringProp name="Header.value">gzip, deflate, br</stringProp>
                    </elementProp>
                    <elementProp name="" elementType="Header">
                      <stringProp name="Header.name">Connection</stringProp>
                      <stringProp name="Header.value">keep-alive</stringProp>
                    </elementProp>
                    <elementProp name="Accept" elementType="Header">
                      <stringProp name="Header.name">Accept</stringProp>
                      <stringProp name="Header.value">*/*</stringProp>
                    </elementProp>
                    <elementProp name="" elementType="Header">
                      <stringProp name="Header.name">Authorization</stringProp>
                      <stringProp name="Header.value">Bearer ${TOKEN_CP}</stringProp>
                    </elementProp>
                  </collectionProp>
                </HeaderManager>
                <hashTree/>
                <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="Извлечь employee_id" enabled="true">
                  <stringProp name="JSONPostProcessor.referenceNames">employee_id</stringProp>
                  <stringProp name="JSONPostProcessor.jsonPathExprs">$.id;</stringProp>
                  <stringProp name="JSONPostProcessor.match_numbers"></stringProp>
                  <stringProp name="JSONPostProcessor.defaultValues">0</stringProp>
                </JSONPostProcessor>
                <hashTree/>
              </hashTree>
            </hashTree>
            <LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="Создать свободные смены" enabled="true">
              <boolProp name="LoopController.continue_forever">true</boolProp>
              <stringProp name="LoopController.loops">${countShiftOnOm}</stringProp>
            </LoopController>
            <hashTree>
              <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Расчитать даты для свободной смены" enabled="true">
                <stringProp name="scriptLanguage">java</stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="cacheKey">true</stringProp>
                <stringProp name="script">	   import java.time.LocalDate;
	   import java.time.LocalTime;
  	   import java.time.format.DateTimeFormatter;

  	   
        LocalDate date = LocalDate.parse(vars.get(&quot;dateOnShift&quot;));
            String startTime = vars.get(&quot;startTime&quot;);
            String endTime = vars.get(&quot;endTime&quot;);

            // Обновляем startTime и endTime для следующей смены
            LocalTime start = LocalTime.parse(startTime, DateTimeFormatter.ofPattern(&quot;HH:mm:ss.SSSSSS&quot;));
            LocalTime end = LocalTime.parse(endTime, DateTimeFormatter.ofPattern(&quot;HH:mm:ss.SSSSSS&quot;));

            start = start.plusSeconds(360); // Начало следующей смены с учетом 4-минутной смены и 2-минутного перерыва
            end = end.plusSeconds(360); // Конец следующей смены с учетом 4-минутной смены и 2-минутного перерыва

            String startFormat = start.format(DateTimeFormatter.ofPattern(&quot;HH:mm:ss.SSSSSS&quot;));
            String endFormat = end.format(DateTimeFormatter.ofPattern(&quot;HH:mm:ss.SSSSSS&quot;));
            vars.put(&quot;startTime&quot;, startFormat);
            vars.put(&quot;endTime&quot;, endFormat);

            vars.put(&quot;sqlStartTime&quot;, date.toString() + &quot; &quot; + startFormat);
            vars.put(&quot;sqlEndTime&quot;, date.toString() + &quot; &quot; + endFormat);

            // Если достигнут конец текущего дня, переходим на следующий день
            if ((start.getHour() == 0 &amp;&amp; start.getMinute() == 0 &amp;&amp; start.getSecond() == 0) ||
                    (end.getHour() == 0 &amp;&amp; end.getMinute() == 0 &amp;&amp; end.getSecond() == 0)) {
                date = date.plusDays(1);
                vars.put(&quot;dateOnShift&quot;, date.toString());
            }
</stringProp>
              </JSR223Sampler>
              <hashTree/>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Создание свободной смены в базе данных магнита" enabled="true">
                <stringProp name="dataSource">db_magnit</stringProp>
                <stringProp name="query">INSERT INTO public.shift (allow_confirm_exchange, available_for_assignment, enddatetime, startdatetime, edited,
     employee_position_id, lunch, pos_cat_roster_id, position_index, worked_status,
     fte_position_group_id, planned_shift_id, positiontype_id, outstaff, extended_status,
     planned_absence, original_id, vacant_shift_type, exchange_rule_id, outer_id,
     job_title_exchange_id, created, updated, external, breaks,
     exchange_status_id, resolve_time, sub_type, create_mode, bio_status, src_shift_id,
     approve_doc_id, creator_id, agreement_file, return_to_exchange, published,
     version, worked, org_unit_id, shift_template_id
     )
VALUES (false, false, &apos;${sqlEndTime}&apos;, &apos;${sqlStartTime}&apos;, true, 
   null, 0, &apos;${positionCategoryRosterId}&apos;, null, null,
    null, null, null, true, null,
    false, null, null, null, null, 
   2, &apos;${createStart}&apos;, &apos;${createUpdate}&apos;, false, null,
    1, null, null, &apos;ES&apos;, null, null,
   null, 1, null, null, false,
   1, false, &apos;${orgUnitId}&apos;, null);
</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes">timestamp, timestamp, bigint</stringProp>
                <stringProp name="queryTimeout"></stringProp>
                <stringProp name="queryType">Update Statement</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
                <stringProp name="resultSetMaxRows"></stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames"></stringProp>
              </JDBCSampler>
              <hashTree/>
            </hashTree>
            <TransactionController guiclass="TransactionControllerGui" testclass="TransactionController" testname="Создание свободной смены через api" enabled="true">
              <boolProp name="TransactionController.includeTimers">false</boolProp>
              <stringProp name="TestPlan.comments">Когда мы создаём смены через БД, то график все равно остаётся опубликованным, нужно создать одну смену через api, чтобы ростер поменялся и его можно было опубликовать, для того, чтобы смены ушли на outstaff</stringProp>
              <boolProp name="TransactionController.parent">false</boolProp>
            </TransactionController>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="&gt;_api/v1/shifts" enabled="true">
                <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">false</boolProp>
                      <stringProp name="Argument.value">{&#xd;
  &quot;_links&quot;: {&#xd;
    &quot;jobTitle&quot;: {&#xd;
      &quot;href&quot;: &quot;https://magnit-master.goodt.me/api/v1/job-titles/2&quot;&#xd;
    }&#xd;
  },&#xd;
  &quot;_errors&quot;: {},&#xd;
  &quot;scheduleItemKind&quot;: &quot;SHIFT&quot;,&#xd;
  &quot;startDate&quot;: &quot;${DATE_NOW}&quot;,&#xd;
  &quot;endDate&quot;: &quot;${DATE_NOW}&quot;,&#xd;
  &quot;repeatRule&quot;: {&#xd;
    &quot;periodicity&quot;: &quot;NO_REPEAT&quot;,&#xd;
    &quot;name&quot;: &quot;Не повторять&quot;&#xd;
  },&#xd;
  &quot;orgUnit&quot;: {&#xd;
    &quot;availableForCalculation&quot;: true,&#xd;
    &quot;availableForStaffingCalculation&quot;: true,&#xd;
    &quot;active&quot;: true,&#xd;
    &quot;_links&quot;: {&#xd;
    },&#xd;
    &quot;id&quot;: ${orgUnitId}&#xd;
  },&#xd;
  &quot;jobTitle&quot;: &quot;Директор магазина&quot;,&#xd;
  &quot;lunch&quot;: 0,&#xd;
  &quot;commentText&quot;: &quot;тест&quot;,&#xd;
  &quot;hiringReasonText&quot;: &quot;Усиление директора&quot;,&#xd;
  &quot;additionalWorks&quot;: [],&#xd;
  &quot;rosterId&quot;: ${active_roster_id},&#xd;
  &quot;statusName_&quot;: &quot;Смена&quot;,&#xd;
  &quot;partners&quot;: [],&#xd;
  &quot;necessaryAddWorkIds&quot;: [],&#xd;
  &quot;originalAdditionalWorks&quot;: [],&#xd;
  &quot;dateTimeInterval&quot;: {&#xd;
    &quot;startDateTime&quot;: &quot;${tStart}&quot;,&#xd;
    &quot;endDateTime&quot;: &quot;${tEnd}&quot;&#xd;
  },&#xd;
  &quot;positionCategoryRosterId&quot;: ${positionCategoryRosterId}&#xd;
}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${BASE_URL}</stringProp>
                <stringProp name="HTTPSampler.port"></stringProp>
                <stringProp name="HTTPSampler.protocol">${PROTOCOL}</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">api/v1/shifts</stringProp>
                <stringProp name="HTTPSampler.method">POST</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
                  <collectionProp name="HeaderManager.headers">
                    <elementProp name="" elementType="Header">
                      <stringProp name="Header.name">Content-Type</stringProp>
                      <stringProp name="Header.value">application/hal+json</stringProp>
                    </elementProp>
                    <elementProp name="" elementType="Header">
                      <stringProp name="Header.name">Accept-Encoding</stringProp>
                      <stringProp name="Header.value">gzip, deflate, br</stringProp>
                    </elementProp>
                    <elementProp name="" elementType="Header">
                      <stringProp name="Header.name">Connection</stringProp>
                      <stringProp name="Header.value">keep-alive</stringProp>
                    </elementProp>
                    <elementProp name="Accept" elementType="Header">
                      <stringProp name="Header.name">Accept</stringProp>
                      <stringProp name="Header.value">*/*</stringProp>
                    </elementProp>
                  </collectionProp>
                </HeaderManager>
                <hashTree/>
              </hashTree>
            </hashTree>
            <TransactionController guiclass="TransactionControllerGui" testclass="TransactionController" testname="Отправить график на публикацию" enabled="true">
              <boolProp name="TransactionController.includeTimers">false</boolProp>
              <boolProp name="TransactionController.parent">false</boolProp>
            </TransactionController>
            <hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="&gt;_api/v1/org-units/${orgUnitId}/rosters" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="from" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">false</boolProp>
                      <stringProp name="Argument.value">${DATE_START_MONTH}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">from</stringProp>
                    </elementProp>
                    <elementProp name="to" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">false</boolProp>
                      <stringProp name="Argument.value">${DATE_END_MONTH}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">to</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${BASE_URL}</stringProp>
                <stringProp name="HTTPSampler.port"></stringProp>
                <stringProp name="HTTPSampler.protocol">${PROTOCOL}</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/v1/org-units/${orgUnitId}/rosters</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON Active Roster Extractor" enabled="true">
                  <stringProp name="JSONPostProcessor.referenceNames">new_active_roster_id</stringProp>
                  <stringProp name="JSONPostProcessor.jsonPathExprs">$._embedded.rosters[?(@.active== true)].id</stringProp>
                  <stringProp name="JSONPostProcessor.match_numbers">1</stringProp>
                  <stringProp name="JSONPostProcessor.defaultValues">null</stringProp>
                </JSONPostProcessor>
                <hashTree/>
              </hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="&gt;_api/v1/rosters/${active_roster_id}/publish?force=false" enabled="true">
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="active" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">false</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">active</stringProp>
                    </elementProp>
                    <elementProp name="publish" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">false</boolProp>
                      <stringProp name="Argument.value">true</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                      <boolProp name="HTTPArgument.use_equals">true</boolProp>
                      <stringProp name="Argument.name">publish</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${BASE_URL}</stringProp>
                <stringProp name="HTTPSampler.port"></stringProp>
                <stringProp name="HTTPSampler.protocol">${PROTOCOL}</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/api/v1/rosters/${new_active_roster_id}/publish?force=false</stringProp>
                <stringProp name="HTTPSampler.method">PUT</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="TestPlan.comments">https://magnitqa-wfm.goodt.me/api/v1/rosters/8129709/publish?force=false</stringProp>
              </HTTPSamplerProxy>
              <hashTree/>
            </hashTree>
            <TransactionController guiclass="TransactionControllerGui" testclass="TransactionController" testname="Получить все requestId" enabled="true">
              <boolProp name="TransactionController.includeTimers">false</boolProp>
              <boolProp name="TransactionController.parent">false</boolProp>
            </TransactionController>
            <hashTree>
              <TestAction guiclass="TestActionGui" testclass="TestAction" testname="FCA_1m" enabled="true">
                <intProp name="ActionProcessor.action">1</intProp>
                <intProp name="ActionProcessor.target">0</intProp>
                <stringProp name="ActionProcessor.duration">${__Random(65000,80000,)}</stringProp>
              </TestAction>
              <hashTree/>
              <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Получить все requstId" enabled="true">
                <stringProp name="dataSource">db_outstaff</stringProp>
                <stringProp name="query">SELECT id FROM public.request WHERE id &gt; ${last_request_id_1} AND status = &apos;CREATED&apos;  AND DATE(created) &gt;= (CURRENT_DATE - INTERVAL &apos;1 day&apos;);</stringProp>
                <stringProp name="queryArguments"></stringProp>
                <stringProp name="queryArgumentsTypes"></stringProp>
                <stringProp name="queryTimeout">60</stringProp>
                <stringProp name="queryType">Select Statement</stringProp>
                <stringProp name="resultSetHandler">Store as String</stringProp>
                <stringProp name="resultSetMaxRows"></stringProp>
                <stringProp name="resultVariable"></stringProp>
                <stringProp name="variableNames">REQUEST_ID</stringProp>
              </JDBCSampler>
              <hashTree/>
            </hashTree>
            <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Записать пользователя в csv файл" enabled="true">
              <stringProp name="cacheKey">true</stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="script">import org.apache.commons.lang3.RandomStringUtils;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

String filePath = &quot;values2.csv&quot;;
Integer value = Integer.parseInt(vars.get(&quot;REQUEST_ID_#&quot;));

FileWriter fw = null;
try {
    fw = new FileWriter(filePath, true);
    File file = new File(filePath);
    if (file.length() == 0) {
        fw.write(&quot;employeeId,requestId,omId\n&quot;);
    }

    for (int a = 1; a &lt;= value; a++) {
    	   String variable = &quot;REQUEST_ID_&quot; + a;
        fw.write(vars.get(&quot;employee_id&quot;) + &quot;,&quot; + vars.get(variable) + &quot;,&quot; + vars.get(&quot;orgUnitId&quot;) + &quot;\n&quot;);
    }
    fw.close();
} catch (IOException e) {
    e.printStackTrace();
}

</stringProp>
              <stringProp name="scriptLanguage">java</stringProp>
            </JSR223Sampler>
            <hashTree/>
            <DebugSampler guiclass="TestBeanGUI" testclass="DebugSampler" testname="Debug Sampler" enabled="true">
              <boolProp name="displayJMeterProperties">false</boolProp>
              <boolProp name="displayJMeterVariables">true</boolProp>
              <boolProp name="displaySystemProperties">false</boolProp>
            </DebugSampler>
            <hashTree/>
          </hashTree>
        </hashTree>
      </hashTree>
      <TestFragmentController guiclass="TestFragmentControllerGui" testclass="TestFragmentController" testname="________________________________________________________________________________________" enabled="false"/>
      <hashTree/>
      <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree" enabled="true">
        <boolProp name="ResultCollector.error_logging">false</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>false</time>
            <latency>false</latency>
            <timestamp>false</timestamp>
            <success>false</success>
            <label>false</label>
            <code>false</code>
            <message>false</message>
            <threadName>false</threadName>
            <dataType>false</dataType>
            <encoding>false</encoding>
            <assertions>false</assertions>
            <subresults>false</subresults>
            <responseData>true</responseData>
            <samplerData>false</samplerData>
            <xml>true</xml>
            <fieldNames>false</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <url>true</url>
          </value>
        </objProp>
        <stringProp name="filename"></stringProp>
      </ResultCollector>
      <hashTree/>
      <ResultCollector guiclass="SummaryReport" testclass="ResultCollector" testname="Summary Report" enabled="true">
        <boolProp name="ResultCollector.error_logging">false</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>false</xml>
            <fieldNames>true</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
            <sentBytes>true</sentBytes>
            <url>true</url>
            <threadCounts>true</threadCounts>
            <idleTime>true</idleTime>
            <connectTime>true</connectTime>
          </value>
        </objProp>
        <stringProp name="filename"></stringProp>
      </ResultCollector>
      <hashTree/>
      <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
        <boolProp name="ResultCollector.error_logging">false</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>false</xml>
            <fieldNames>true</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
            <sentBytes>true</sentBytes>
            <url>true</url>
            <threadCounts>true</threadCounts>
            <idleTime>true</idleTime>
            <connectTime>true</connectTime>
          </value>
        </objProp>
        <stringProp name="filename"></stringProp>
      </ResultCollector>
      <hashTree/>
    </hashTree>
  </hashTree>
</jmeterTestPlan>
